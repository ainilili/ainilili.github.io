<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="我是Nico，梦想是做一名兴趣使然的码农，于是我一步步变强，后来我成为了光头">
<meta name="keywords" content="“博客,Java,Python,Node,开源,框架,并发,Mysql”">
<meta property="og:type" content="website">
<meta property="og:title" content="Nico&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Nico&#39;s Blog">
<meta property="og:description" content="我是Nico，梦想是做一名兴趣使然的码农，于是我一步步变强，后来我成为了光头">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nico&#39;s Blog">
<meta name="twitter:description" content="我是Nico，梦想是做一名兴趣使然的码农，于是我一步步变强，后来我成为了光头">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Nico's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nico's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">兴趣使然的Coder</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/22/存储介质/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/22/存储介质/" itemprop="url">存储介质</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-22T12:35:00+08:00">
                2022-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><strong>前言</strong></h1>
<p>开发一个简单的应用，我们只需要掌握mysql的增删改查即可，这看起来是一件非常easy的事情，而事实确实如此，但是前提是我们的目标是冲着<strong>简单</strong>去的。再将小目标强化一下，我们想开发复杂一些的应用，这不得不需要我们进一步加强对mysql的了解，例如索引等调优技术，随着目标的不断加强，我们需要对于整个应用所涉及到的技术拥有更加透彻的认知。</p>
<p>从此刻开始，让我们将思想坠入硬件层，深入但是又不太深入的了解一下各种存储介质的存储原理。</p>
<h1><strong>HDD</strong></h1>
<p>机械硬盘HDD（Hard Disk Drive）是一款磁物质存储类型的硬盘，它通过磁头转轴带动磁头在磁盘上运动来达到存储的目的，在此过程中，磁头不会与磁盘接触，电机控制磁头的电磁流来影响磁盘上磁极发生正负变化，从而做到存储二进制数据。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67913aad349540bfbaae1ab58a649c7a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>HDD的大体结构也并不算复杂。从平面来看，它主要由磁头、盘片、电机、磁头、转轴等组成。从侧面来看，HDD不止一个盘片，每个盘片都有正反两个盘面，每个盘面都配有一个磁头。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ca819063c047529599f8958f6cbed0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>HDD在逻辑上又划分为磁道、柱面、扇区。每个盘面上被划分成许多同心圆，每个同心圆的圆周被称为磁道，离转轴最远（最外圈）的磁道为0号磁道，读写将会从0号磁道开始向内圈移动。多个盘面垂直方向同轴磁道组成了柱面。同时，每个盘面又被切分成多个扇形区域，每个扇形区域被称为扇区。扇区是机械硬盘的基本读写单位，每个扇区容量为512Byte，扇面外圈的扇区虽然比内圈看着要大一些，实则磁物质密度会比内圈低很多，最终容量并不会因此而改变。</p>
<p>值得一提的是，因为磁头切换磁道需要臂杆做机械运动，所以效率很低，而切换柱面只需要电控磁头，所以所有磁头同一时刻都是同轴的，读写过程也并不是按照盘面来写，而是先写磁道，磁道满了以后向下写入同一柱面的其它磁道，当整个柱面都写满以后再切换到下一个柱面。由于所有盘片都固定在转轴上，而磁头也只能验证盘片半径方向运动，所以多盘机械硬盘面多多个读写指令，也只能串行处理。</p>
<p>当需要做数据读写时，首先拿到要读数据的盘面号、扇区号和磁头号，然后转轴带动盘片到对应的扇区，机械臂带动对应的磁头移动到对应的柱面，读写完毕之后再进行下一个读写指令的处理。</p>
<h1><strong>DRAM</strong></h1>
<p>动态随机存储器DRAM（Dynamic Random Access Memory）又简称为内存，相比ROM（Read-Only Memory）的非易失性，DRAM的数据会随着断电而消失，因此，DRAM一般被用于临时存储，而非持久化场景。另外，因为电容存在漏电现象，长时间的断电会导致电荷流失以至于数据失真，所以DRAM会周期性的刷新充电，这也是“动态”的由来。</p>
<p>DRAM的存储的原理是通过电容来存储电荷，通过电荷量来表示二进制中的0和1。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dedc7f6ccda43428c4763c5b0098419~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>上图为DRAM存储电路逻辑图，整个数字电路做的事情只是为了存储1bit的数据，其中电容（Capacitor）用来存储电荷，晶体管（Transistor）用来控制外部对电容的访问，Worldline为字线（行），Bitline为数据线（列），整个电路组成了DRAM存储的最小单元cell，实际应用中，无数个cell以矩阵的形式排列，这种矩阵被称为bank，一个bank中的cell通过行地址和列地址进行唯一标识。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c002802552734bfab4fb42208750e422~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>在数据读写之前，需要先对目标cell进行寻址。首先通过行地址解码器定位到行地址线路并发出行地址选通脉冲RAS（Row Address Strobe）信号，因为Capacitor相比Bitline上的电容值相差太大，当从Capacitor上读取数据时对于Bitline上电压影响非常小，导致无法有效识别具体数据，所以在RAS信号激活后，需要使用读出放大器（Sense Amplifier）将电容充放电信号放大，这个过程称为Activate。</p>
<p>当RAS信号被激活后，通过列地址解码器定位到列地址线路并发出列地址选通脉冲CAS（Column Address Strobe）信号，之后放开Transistor，通过改变外部电压状态来感应或改变Capacitor中的电荷以完成数据读写，这个过程称为Precharge。</p>
<p>在读取过程中，因为Capacitor与Bitline上的电压差，这样会使Capacitor上的电容量发生变化，导致下次读取失真，为了保证每次读取到的数据都是准确的，在读取完毕后需要再次充电操作。</p>
<p>为了更好的描述性能，引入了描述内存性能的四个时序参数：CL、TRCD、TRP和TRAS，单位为时钟周期（ns级），每个参数周期如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d4e91f879041938bb56721cdc4f48f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>因为DRAM定时充电刷新的特性，性能会受到一定的影响，而静态随机存储器SRAM（Static Random Access Memory）弥补了这个缺陷，它不需要定时刷新，只要存储器保持通电，数据就可以持久保存，当然断电后仍然会丢失。SRAM之所以能做到这一点，是因为它去掉了电容，通过两个耦合的反相器的来锁住输出状态，有兴趣可以私下深究。</p>
<h1><strong>SSD</strong></h1>
<p>固态硬盘SSD（Solid State Disk或Solid State Drive）是基于半导体闪存（NAND Flash）作为存储介质的硬盘，相比传统的机械硬盘，它去掉了机械固件，引入了主控芯片来代替机械操作，这意味着它的性能、功耗及可靠性会比HDD高出一大截。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7391f8e215614baaa179d807a5fe54d9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>Flash闪存是一种非易失性的内存，这意味着即使断电也不会丢失数据，使用双层浮栅（Floating Gate）MOS管作为存储单元cell，与DRAM 1T1C（一个Transistor + 一个Capacitor）存储方式不同的是，浮栅晶体管上下被绝缘层包围，可以将电子锁在其中，避免数据因掉电而消失。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b9985ac6c0d4d459525505abb063351~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>SSD目前的存储单元根据存储量的大小分为SLC（Single Level Cell）、MLC（Multiple Level Cell）和TLC（Triple Level Cell），就像名称所蕴含的意思一样，SLC可存储1bit数据，MLC可存储2bit数据，TLC可存储3bit数据。SLC是最简单的，其内部状态只有0和1，而MLC要同时存在2bit数据，其内部状态数量增加到了 2^2 个 ，分别为是00/01/10/11，同理，TLC也可以推出它的内部状态数量为 2^3 个，分别为000/001/010/011/100/101/110/111，可以发现，随着存储量的增加，存储单元内部的状态呈指数倍上升，要识别出具体的状态，就要将电子个数进行更细致的划分，这也就意味着读写时的控制更加精细，如果抛开存储数据量的差异，单纯在性能上作比较的话，SLC是最强的，其次是MLC。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c703ce31bb24125a53f18d073e589f2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>与DRAM类型，SSD结构上同样分层，主控通过多个通道Channel操作多块Flash闪存颗粒DIE（硅晶片，也被称为逻辑单元LUN），一个DIE由多个Plane组成，一个Plane由多个Block组成，每个Block下包含若干个Page。其中Block是擦除的最小单位，Page是最小的读写单位。每个Plane都有独立的Cache Register和Page Register，大小与Page一样，目的是做主控和存储介质之前的缓冲区。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/586e960c3da540d8ab264b4742359a3a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>Page大小一般为4KB的整数倍，作为闪存读写最小单位，哪怕读写1byte数据，也要访问整个Page。同时，Page不允许覆盖写，举个例子，先写入1byte数据到Page1，再写入1byte数据时不会因为Page1未满就追加进去，而是先读出Page1中之前的1byte数据并与新数据合并后写入Page2，之后将Page1标记为stale，等待被GC。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa35b26e384043ee9182d7d89be8e857~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>因为闪存不能覆盖写，想要在老地方写数据，只能先擦除，这个过程会对闪存块造成一定的磨损，当闪存块的寿命结束，将会成为坏块，另外闪存块读的次数太多也会导致上面数据失真，所以SSD中的闪存转换层FTL（Flash Translation Layer）至关重要。它通过来维护一张映射表（Map Table）来完成用户逻辑地址到闪存物理地址的转换，另外为了避免上述一系列问题，FTL还做了很多“份外”之事，包括但不仅限于：</p>
<ul>
<li>垃圾回收（Garbage Collection）：当闪存写入达到阈值时，触发GC回收，腾出更多的写入空间。</li>
<li>磨损平衡（Ware Leveling）：为了延长Block寿命，要避免对某些Block高频读写，保证所有块的均衡写入。</li>
<li>消除读干扰（Read Disturb）：当闪存块读取达到阈值时，FTL将这些数据迁移至其它块。</li>
</ul>
<h3 id="映射管理"><a class="header-anchor" href="#映射管理">¶</a><strong>映射管理</strong></h3>
<p>用户逻辑地址到闪存物理地址的转换是FTL本职工作，FTL在内部维护了一张映射表，其中维护了用户逻辑空间到闪存空间中Block或Page的映射关系。</p>
<p>在进行读写时，用户通过逻辑地址访问SSD，会先经过映射表的转译来获取闪存物理地址再进行之后的操作，假如是对新块写操作，此时映射表并没有当前映射关系，经过FTL挑选合适的块写入后，映射表中会将当前映射记录下来。</p>
<p>映射表本身也会占用一定的空间用于自身的存储，SSD也都会为此类事情预留一部分空间。由于映射表的访问很频繁，通常会将映射表存储在RAM中，市面上有些SSD的主板上会自带一块小型DRAM用于映射表的缓存，而另外一部分SSD则选择会使用主机内存。</p>
<h3 id="垃圾回收"><a class="header-anchor" href="#垃圾回收">¶</a><strong>垃圾回收</strong></h3>
<p>因为闪存不能覆盖写的特性，每次写入老块之前都要先擦除，这个过程就是先将块数据读出，将有用数据读取出来，然后将当前块擦除，再将<strong>有效数据</strong>和当前数据一起写入目标块中，这个过程做的操作简称为<strong>读擦写</strong>，而这个过程为称为垃圾回收（GC）。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7751428f19184c5b8e799a16b016c193~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>新盘刚开始写入过程中，因为是空盘，所以不会触发GC，当硬盘空间可用量小于某一个阈值时，GC操作将会触发。在GC之前，用户数据会先写入预留空间OP（Over Provisioning）中，这个空间对用户不可见，所以通常我们拿到收的硬盘可用空间往往会比规格容量小一些。</p>
<p>很明显，这种GC会使原本简单的操作变得复杂且低效，并且相比原本要写入的数据，会对块中<strong>有效数据</strong>做额外的写入，这种现象称为写放大WA（Write Amplification），计算公式为：<code>WA = 实际写入量 / 用户数据量</code>，其中<code>实际写入量 = 块有效数据量 + 用户数据量</code>。可以看出，块中的垃圾密度越大，有效数据就越小，WA也随之而然的跟着变小。</p>
<p>另外，SSD中GC有两种触发方式，一种是前台垃圾回收Foreground GC，它在用户写入数据无可用块时主动触发，另外一种是后台垃圾回收Background GC，它在SSD空闲时由内部控制触发。前者出发时，用户写入需要额外等待GC的完成，后者则尽可能避免前者带来的时间的耗费。</p>
<h3 id="4k对齐"><a class="header-anchor" href="#4k对齐">¶</a><strong>4K对齐</strong></h3>
<p>传统HDD扇区单位一直习惯于512Byte，有些文件系统默认保留前63个扇区，也就是前<code>512 * 63 / 1024 = 31.5</code>KB，假设闪存Page和簇（OS读写基本单位）都大小为4KB，那么一个Page对应着8个扇区，用户数据将于第8个Page的第3.5KB位置开始写入，导致之后的每一个簇都会跨两个Page，读写处于超界处，这对于闪存会造成更多的读损及读写开销。</p>
<p>除了OS层的4K对齐至关重要以外，在文件写入过程中仍然需要关注4K对齐的问题。假设Page大小仍然为4KB，向一个空白文件写入5KB数据，此时需要2个Page来存储数据，并且可以写满Page1，而Page2只写入1KB数据，当再次向文件顺序写入数据时，仍然需要读取Page2的数据与新写入数据合并再写入新的Page中，此时额外的开销已经产生了。</p>
<p>对于这种情况我们可以人工补齐4K来避免额外的读开销，当然这个优化不是必须的，同时要结合自己的实际场景来做抉择。</p>
<h3 id="读写顺序"><a class="header-anchor" href="#读写顺序">¶</a><strong>读写顺序</strong></h3>
<p>顺序读写和随机读写一直以来都是读写性能优化中最重要的一点，无论HDD还是SSD，读写方式的不同所带来的影响也不同。随机读写意味着要重新寻址，对于HDD来说需要磁头的切换甚至柱面的切换，SSD则需要重新定位行列地址线，相比于HDD，SSD不需要机械运动，因此随机读写带来的影响会小很多，而顺序读写可以免去再次寻址过程，在应用设计允许的情况下，顺序读写都是最优之选。</p>
<p>对于SSD来说，顺序写可以保证数据有序的写在相邻的Page和Block中，当数据或文件删除时，GC垃圾也相对比较集中，可以大大降低WA带来的影响。</p>
<p>主流操作系统都会有预读，顺序读可以提高预读缓存命中率，减少硬件读取次数。所以，如果可以，请尽可能顺序读写。</p>
<h1><strong>参考</strong></h1>
<ul>
<li><a href="https://www.cnblogs.com/whl320124/articles/10063813.html" target="_blank" rel="noopener">深入了解机械硬盘的读写原理和碎片的产生</a></li>
<li><a href="https://blog.csdn.net/wangshouchao/article/details/48606639" target="_blank" rel="noopener">内存（DRAM）的工作原理及时序介绍</a></li>
<li><a href="http://www.wowotech.net/basic_tech/307.html" target="_blank" rel="noopener">DRAM 原理 1 ：DRAM Storage Cell</a></li>
<li><a href="http://hardwarehell.com/articles/ras_cas.htm" target="_blank" rel="noopener">Meaning Behind Ram RAS and CAS</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/52272990" target="_blank" rel="noopener">浅聊SRAM和DRAM的区别</a></li>
<li><a href="https://blog.joway.io/posts/ssd-notes/" target="_blank" rel="noopener">SSD 背后的奥秘</a></li>
<li><a href="https://item.jd.com/12367097.html" target="_blank" rel="noopener">深入浅出SSD - 固态存储核心技术原理与实战</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/22/【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/22/【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计/" itemprop="url">【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-22T12:25:00+08:00">
                2022-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引子"><a class="header-anchor" href="#引子">¶</a>引子</h2>
<p>在一个浑浑噩噩的下午，百无聊赖的我像往常一样点开了划水交流群，细细品味着老哥们关于量子力学的讨论。嬉戏间，平常水不拉几的群友张三忽然发了一张大大的橙图，我啪的一下点开了，很快啊，仔细观摩后发现原来是2021第二届云原生编程挑战赛报名的海报，暗暗的想起了被我鸽掉的前几届，小手不自觉地打开了链接并且一键三连。</p>
<p>每个人的心里都有一个童心未泯的自己，这次比赛就像一场游戏一样让我深陷其中，三岔路口，我选择了存储领域，谁承想这决定会让我在接下来的两个月里减少百分之N的发量。</p>
<h2 id="读题"><a class="header-anchor" href="#读题">¶</a>读题</h2>
<p><a href="https://tianchi.aliyun.com/competition/entrance/531922/information" target="_blank" rel="noopener">赛题</a>目的是实现简单的消息读取与存储，程序需要实现<code>append</code>和<code>getRange</code>方法，并依次通过性能评测与正确性评测，性能评测耗时最少者居高。</p>
<h3 id="评测环境"><a class="header-anchor" href="#评测环境">¶</a>评测环境</h3>
<p>Linux下的4核8G服务器，配置<code>400G</code> ESSD PL1云盘，吞吐可达<code>320MiB/s</code>，<code>60G</code> Intel 傲腾持久内存PMem（Persistent Memory），由参考文档可推测为第一代持久内存，代号为AEP。</p>
<p>赛题编程语言限制为Java8，JVM配置为6G堆内+2G堆外。</p>
<h3 id="性能评测"><a class="header-anchor" href="#性能评测">¶</a>性能评测</h3>
<p>评测程序首先会创建10~50个不等的线程，每个线程随机分配若干个topic进行写入，topic总数量不超过100个。每个topic之下又分为若干个queue，总数量不超过5000个，调用append方法后返回当前数据在queue中的offset，由0开始。每次写入数据大小为100B-17KiB区间随机，当写满75G数据后，会挑选一半的queue由下标0（头）开始读取，另外一半从当前最大下标（尾）开始读取，并保持之前的写入压力继续写入50G数据，最后一条数据读取完毕后停止计时。</p>
<h3 id="正确性评测"><a class="header-anchor" href="#正确性评测">¶</a>正确性评测</h3>
<p>同样会使用N个线程写入数据，在写入过程中会重启ECS，之后再读取之前写入成功的数据（返回offset即视为成功），要求严格一致。</p>
<h3 id="持久内存"><a class="header-anchor" href="#持久内存">¶</a>持久内存</h3>
<p>本次比赛多了一个比较陌生的存储介质PMem，它结合了内存的读写性能和持久化的特性，可以在延迟可以控制在纳秒级。</p>
<p>目前主流的实现为非易失性双列直插式内存模块NVDIMM（Non-Volatile Dual In-Line Memory Module，NVDIMM），它是持久内存的一种实现，目前有三种实现标准：</p>
<ul>
<li><strong>NVDIMM-N：</strong> 配置同等容量的DRAM和NAND Flash，另外还有一个超大电容，当主机断电后，PMem设备会使用电容中保留的电量保证DRAM的数据同步到闪存中。</li>
<li><strong>NVDIMM-F：</strong> 使用了适配DDR规格的NAND Flash，通过多个控制器和桥接器将DDR总线信息转化为SATA协议信息来操作闪存的读写。</li>
<li><strong>NVDIMM-P：</strong> 同样配置了DRAM和NAND Flash，只不过DRAM容量会比闪存少很多，DRAM在其中作为闪存上层的缓存以优化读写性能，同样使用超大电容来保障断电后的脏数据持久。</li>
</ul>
<p>Intel傲腾第一代持久内存AEP遵循<strong>NVDIMM-P</strong>标准，实现了非易失性，可以按字节寻址（Byte Addressable）操作，小于1μs的延时，以及集成密度高于或等于DRAM等特性。不同于传统的NAND Flash实现，傲腾持久内存使用了新型非易失性存储器3D-XPoint，其内部是一种全新的存储介质。</p>
<p>Intel傲腾持久内存提供多种操作模式：</p>
<ul>
<li><strong>内存模式：</strong> 此模式下持久内存被当做超大容量的易失性内存使用，其中DRAM被称为近内存（Near Memory），持久化介质被称为远内存（Far Memory），读写性能取决于读写时命中近内存还是远内存。</li>
<li><strong>AD模式：</strong> 此模式下持久内存直接暴露给用户态的应用程序直接调用，应用程序通过持久内存感知文件系统（PMEM-Aware File System）将用户态的内存空间直接映射到持久内存设备上，从而应用程序可以直接进行加载（Load）和存储（Store）操作。这种形式也被称作DAX，意为直接访问。目前主流的文件系统ext4, xfs 都支持Direct Access的选项（-o dax)，英特尔也提供了用于在持久内存上进行编程的用户态软件库PMDK。</li>
</ul>
<p>本次比赛使用AD模式。</p>
<h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2>
<p>首先关注的是正确性评测，写入过程会重启ECS，那么就要保证在append方法return之前数据要落盘，也就是说每个写入请求都要fsync刷盘。另外在重启ECS之后，会清理PMem上的数据，所以数据肯定要在ESSD上保存一份。</p>
<p>总写入数据量为125G，而ESSD提供400G容量，正常写入的情况下不用考虑硬盘GC的问题。除了ESSD空间外，我们还有60G的PMem可用，而且文件系统通常会预留一部分文件空间作紧急情况使用，所以PMem可用容量会更高（实测真实容量为62G左右）。DRAM内存也要尽可能利用起来，首选不受JVM限制的2G堆外，剩下的6G堆内如何使用就要在GC和整体性能之间做抉择了。</p>
<h3 id="文件写入"><a class="header-anchor" href="#文件写入">¶</a>文件写入</h3>
<p><strong>方案1：</strong> 每个queue一个文件，这样可以保证顺序读写，但最坏的情况下需要创建100 * 5000 = 500,000个文件，操作系统默认每个用户进程1024个句柄肯定会超限。</p>
<p><strong>方案2：</strong> 每个topic一个文件，那么最坏只需要创建100个文件，可以接受，但这意味着多个queue的数据要写入同一个文件中，无法保证顺序读写，不过可以是使用稀疏索引来做块存储。另外因为正确性评测的限制，我们需要在每次写入后手动fsync，所以这种设计下会导致频繁的fsync，也就意味着用户态与内核态之间要频繁的切来切去，另外数据大小范围为100B~17KiB，ESSD在一次写入32K以上数据时才能发挥最优性能，很明显当前设计是打不满ESSD PL1的吞吐的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7373739442514f56b877687dc35a853b~tplv-k3u1fbpfcp-zoom-1.image" alt="enter image description here"></p>
<p><strong>方案3：</strong> 所有topic共用一个文件，通过对以上弊端的思考，我们应该尽可能每次fsync时写入更多的数据，由于N个线程并发写同一个文件，所以我们可以将N个线程的数据先写入聚合缓冲中后并挂起，等待将缓冲中的数据刷盘后再取消阻塞。这个方案可以保证顺序写随机读，每次写入数据足够多，并且减少了核态的切换次数，但是刷盘变成了串行，或许能得到一个不错的ESSD吞吐，但是对CPU造成了浪费。</p>
<p>在上一个假设上做优化，因为评测环境配置4核CPU，我们将所有线程分为4组，每组对应一个文件，这样既可以保证ESSD的性能，又可以在无法绑核的情况下尽可能压榨所有CPU的性能。</p>
<p>文件读写的API方面，首先放弃传统的FileWriter/FileRead，相比而言，FileChannel提供双向读写能力且更易操控读写数据精度。MMap是另外一种方案，因为它只在创建的时候需要切态，理论上它的读写速度会比FileChannel更快，但是由于种种原因，MMap映射大小受限，这无疑增加了程序设计上的维护成本，另外最终场景每次写入数据量平均在64KB左右，通过Benchmark，FileChannel在这种场景下性能总是优于MMap。最终选定使用FileChannel进行文件读写，另外为了减少用户与向内核态的内存复制，使用DirectByteBuffer用作写入缓冲。</p>
<p>**最终方案：**将所有线程分为4组，充分利用多核CPU，每组对应一个AOF数据文件，每组线程的数据写入缓冲后并挂起，缓冲刷盘后再取消阻塞，返回offset。</p>
<h3 id="缓存利用"><a class="header-anchor" href="#缓存利用">¶</a>缓存利用</h3>
<p>首先要明确一点，在本次赛题中，无论是DRAM还是PMem，都不能利用它们用来做数据的持久化（PMem正确性阶段重启后会做数据清理），ESSD是必须要求写入的。因此，缓存的主要利用方向在于提高读性能。</p>
<p>首先是性能最快但是容量最小的DRAM，官方不允许使用<code>unsafe</code>来额外分配堆外的堆外内存，所以可供我们使用的DRAM只有2G的堆外以及6G的堆内，又由于JVM的GC机制外加程序本身的业务流程需要一定的内存开销，所以6G的堆内可供我们用来做数据存储的部分大打折扣（实际测下来可以用到3.2G），而堆外内存会有一部分用于文件读写缓冲，所以堆外内存可用量也会小于2G。另外就是62G的持久内存PMem，由于其性能优于ESSD数百倍，容量远大于DRAM，且ext4支持dax模式，可直接用FileChannel操作读写，对于它的合理使用直接决定了最终成绩的好坏。</p>
<p>再回到性能评测上进行分析，我们将整个过程分为是三个阶段（重点，下文要考）：</p>
<ul>
<li><strong>一阶段：</strong> 先写入<code>75G</code>的数据。</li>
<li><strong>二阶段：</strong> 评测程序随机挑选一半的queue从头开始读，另一半从结尾开始读，并在读的同时，继续写入<code>50G</code>的数据。</li>
<li><strong>三阶段：</strong> 随着时间的推移，最终读取的offset点位会慢慢追赶上当前写入的点位，此阶段中刚写入的数据有可能下一刻被读取。</li>
</ul>
<p>经过分析，我们需要在一阶段尽可能的将数据写入缓存，这样二阶段读取时可以减少ESSD的命中率。由于二阶段会有一半的queue从结尾开始读数据，这也就意味着这些queue之前的数据可以被淘汰，淘汰后的缓存可以复用于之后写入的数据。另外由于二阶段的过程是边读边写，读后的缓存也可以投入复用。</p>
<p>所以理论上二阶段所有写入的数据全部可以复用到淘汰后的缓存。到了三阶段后，应该尽可能使用性能最高的DRAM来存储热数据。</p>
<p>**最终方案：**一阶段首先将缓存写入大约5G的DRAM中，之后的数据写入62G的PMem中（此过程的ESSD一直保持着写入），每个记录的缓存信息保存在对应的queue中。来到二阶段后，将淘汰的缓存按介质类型及大小放入不同的缓存池，之后写入的数据会优先向DRAM缓存池申请缓存块，其次是PMem缓存池。</p>
<p>当然，前期的分析也只能基于理论，最终方案的背后是无数个日日夜夜的测试和思考（卷就完了。</p>
<h2 id="整体方案"><a class="header-anchor" href="#整体方案">¶</a>整体方案</h2>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/868a0b81eaf147598a3159f10c5cebf0~tplv-k3u1fbpfcp-watermark.image?" alt="QQ截图20211206174435.png"></p>
<p>一阶段开始，将所有线程随机分为4组，每组对应1个AOF文件，在写入ESSD的同时，异步写入DRAM或PMem中。理论上在写入 <code>5G + 62G = 67G</code> 数据后缓存用尽，从此刻开始到写满75G之前都只是单纯写硬盘，所有的异步任务也将在此期间全部执行完毕。</p>
<p>二阶段开始，每次读取都会淘汰失效的缓存并放入缓存池中，写入过程中会优先按照记录大小从缓存池中获取到相应的缓存块，理想情况下每次都能申请到对应的缓存块并写入，Missing时记录数据在ESSD上的位置索引。</p>
<p>每次读取时，根据offset从获取对应的数据索引，到索引指定的介质中读取数据并返回。</p>
<h3 id="缓存池"><a class="header-anchor" href="#缓存池">¶</a>缓存池</h3>
<p>本次赛题一共有DRAM，PMem以及ESSD三种介质，而读写的最小颗粒度为100B-17KiB的数据，我们将多个介质的的操作抽象为 <code>Data</code> 类，它提供单条数据读写功能，每种介质单独实现抽象方法，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 缓存块大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line">		<span class="comment">// 数据在文件中开始存储的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> position;</span><br><span class="line">    <span class="comment">// 从介质中读取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(ByteBuffer buffer)</span></span>;</span><br><span class="line">	  <span class="comment">// 从介质中写入</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ByteBuffer buffer)</span></span>;</span><br><span class="line">    <span class="comment">// 从介质中清除</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一阶段中，会按照写入大小创建对应介质的Data，它记录了这条数据在当前介质中的索引信息（如果是DRAM则直接存放ByteBuffer指针），例如当DRAM和PMem写满时，Data记录的是当前数据在ESSD中的position以及capacity。</p>
<p>二阶段开始时，随着queue的读写会淘汰无效的DRAM和PMem Data并放入对应的缓存池中，二阶段过程中的写入会优先从DRAM缓存池中获取闲置的Data，如果获取失败则从PMem缓存池获取，如果依然失败会降级为SSD Data（相当于不走缓存）。如果获取成功，则将数据写入到当前缓存块中并记录在Queue索引中。</p>
<p>由于二阶段中的缓存块都是从缓存池中获取，因此缓存块大小是固定的，会出现块大小 <strong>小于</strong>当前写入数据大小的情况，当发生此类情况时，不足的大小会使用预留的堆外内存补救，这块数据被称为 <code>ext</code>，调用clear()方法同时会释放 <code>ext</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1e2944bff44ce9a3fa82420534cf94~tplv-k3u1fbpfcp-zoom-1.image" alt="enter image description here"></p>
<p>另外，为了减少使用额外的 <code>ext</code> ，缓存池会根据 <code>Data</code> 的capacity大小将之进行分组，当从缓存池获取闲置缓存块时，会根据写入数据的大小到缓存池分组中进行匹配，取出合适区间中的缓存块进行使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 17K / 5 五组内存回收池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LinkedBlockingQueue&lt;Data&gt; <span class="title">getReadBuffer</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cap &lt; Const.K * <span class="number">3.4</span> ? <span class="keyword">null</span> : cap &lt; Const.K * <span class="number">6.8</span> </span><br><span class="line">															 ? readBuffers2 : cap &lt; Const.K * <span class="number">10.2</span> </span><br><span class="line">														   ? readBuffers3 : cap &lt; Const.K * <span class="number">13.6</span> </span><br><span class="line">															 ? readBuffers4: readBuffers5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据索引"><a class="header-anchor" href="#数据索引">¶</a>数据索引</h3>
<p>程序执行过程中，数据写入后会记录一条索引到具体的queue中，由于offset从0开始并有序的特性，每个queue中会实例化一个 <code>ArrayList</code> 来记录该索引，下标即是offset，value的话则为 <code>Data</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Data&gt; records;</span><br></pre></td></tr></table></figure>
<h3 id="aof中的数据格式"><a class="header-anchor" href="#aof中的数据格式">¶</a>AOF中的数据格式</h3>
<p>由于准确性阶段需要数据的recover，所以直接存储在AOF中的数据需要记录一些额外的索引信息：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47427dbeae444e02867a4ef036b54c57~tplv-k3u1fbpfcp-zoom-1.image" alt="enter image description here"></p>
<p>当recover时，首先会读取9个Byte来获取头信息，当校验通过后，会根据Data Len来继续读取真实的数据，之后根据TopicId，QueueId，Offset等信息找到目标队列预先建立索引。</p>
<h3 id="文件预分配"><a class="header-anchor" href="#文件预分配">¶</a>文件预分配</h3>
<p>根据官方渠道得知，评测环境使用的文件系统为ext4，在ext4文件系统下，每次创建一个物理文件会子啊系统中注册一个inode来记录文件的元数据信息以及block索引树的根节点。</p>
<p>当我们对文件进行读写时，首先会从extent tree中寻找合适的block逻辑地址，再从block中拿到硬盘设备中的物理地址方可操作。如果找不到合适的extent或block则需要创建，此过程还涉及到inode中元数据的变动，对内核代码简单追踪可知，最终会调用 <code>ext4_do_update_inode</code> 方法完成inode的更新。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ext4_write_begin</span><br><span class="line">    __block_write_begin</span><br><span class="line">        get_block -&gt; ext4_get_block_unwritten</span><br><span class="line">            _ext4_get_block</span><br><span class="line">                ext4_map_blocks</span><br><span class="line">                    ext4_ext_map_blocks</span><br><span class="line">                        ext4_ext_insert_extent</span><br><span class="line">                            ext4_ext_dirty</span><br><span class="line">                                ext4_mark_inode_dirty</span><br><span class="line">                                    ext4_mark_iloc_dirty </span><br><span class="line">                                        ext4_do_update_inode</span><br></pre></td></tr></table></figure>
<p>其内部实现过程中会先上文件内全局的自旋锁spin_lock()，在设置完新的block并更新inode元数据后调用spin_unlock()解锁，之后处理脏元数据，这个过程需要记录journal日志。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b39a87dfbd0a44b7a42b2548cfa9efc4~tplv-k3u1fbpfcp-zoom-1.image" alt="enter image description here"></p>
<p>对于一个空文件进行持续的写入，每当 <code>ext4_map_blocks()</code> 获取block失败，就会执行复杂的流程来创建新的逻辑空间到物理空间的block映射，这种开销对于性能的影响是非常致命的，对于分秒必争的比赛更是如此。</p>
<p>为了避免这段开销，我们可以在写入空白文件之前预先写入足够多的数据，让inode预热一下，之后再从position 0开始写入。这种方法称为 <strong>预分配</strong> ，Linux中提供 <code>fallocate</code> 命令完成这种操作，在Java中可以手动完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fallocate</span><span class="params">(FileChannel channel, <span class="keyword">long</span> allocateSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (channel.size() == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> batch = (<span class="keyword">int</span>) (Const.K * <span class="number">4</span>);</span><br><span class="line">          <span class="keyword">int</span> size = (<span class="keyword">int</span>) (allocateSize / batch);</span><br><span class="line">          ByteBuffer buffer = ByteBuffer.allocateDirect(batch);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batch; i ++)&#123;</span><br><span class="line">              buffer.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">              buffer.flip();</span><br><span class="line">              channel.write(buffer);</span><br><span class="line">          &#125;</span><br><span class="line">          channel.force(<span class="keyword">true</span>);</span><br><span class="line">          channel.position(<span class="number">0</span>);</span><br><span class="line">          Utils.recycleByteBuffer(buffer);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当然，预分配不是适用于所有场景，本次赛题的计时从第一次append开始，所以有足够的时间在程序初始化过程中完成预分配。再者就是SSD硬盘空间的容量最好足够大，如果容量与要写入的数据相当，预分配后再进行写入时，会导致SSD内部频繁的Foreground GC，性能下降。</p>
<h3 id="4k对齐"><a class="header-anchor" href="#4k对齐">¶</a>4K对齐</h3>
<p>传统HDD扇区单位一直习惯于512Byte，有些文件系统默认保留前63个扇区，也就是前<code>512 * 63 / 1024 = 31.5</code>KB，假设闪存Page和簇（OS读写基本单位）都大小为4KB，那么一个Page对应着8个扇区，用户数据将于第8个Page的第3.5KB位置开始写入，导致之后的每一个簇都会跨两个Page，读写处于超界处，这对于闪存会造成更多的读损及读写开销。</p>
<p>除了OS层的4K对齐至关重要以外，在文件写入过程中仍然需要关注4K对齐的问题。假设Page大小仍然为4KB，向一个空白文件写入5KB数据，此时需要2个Page来存储数据，Page 1写满了4KB，而Page2只写入1KB，当再次向文件顺序写入数据时，需要将Page2数据预先读出来，然后与新写入数据在内存中合并后再写入新的Page 3中，之前的Page 2则标记为 <code>stale</code> 等待被GC。这种带来的开销被称为写入放大WA（Write Amplification）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7718674f47284afba5fff121cac804db~tplv-k3u1fbpfcp-zoom-1.image" alt="enter image description here"></p>
<p>为了减小WA，我们可以人工补充缺少的数据。对于本次赛题，当写入缓冲刷盘前，将写入Buffer的position右移至最近的4KB整数倍点位即可。</p>
<h3 id="预读取"><a class="header-anchor" href="#预读取">¶</a>预读取</h3>
<p>二阶段中，我们需要做的是从queue中获取请求区间所有的 <code>Data</code> ，并根据 <code>Data</code> 中的索引信息将真实数据从对应介质中读取出来，而且这个过程通常是批量的，具体数量由入参 <code>fetchNum</code> 控制。</p>
<p>最开始我使用 <code>Semaphore</code> 对批量数据多线程并发读，并且得到了不错的效果。但是背后却埋着不小的坑，由于每次getRange要频繁的对多个线程阻塞和取消阻塞，线程上下文切换带来开销非常严重，有兴趣的读者可以运行以下测试代码（并把 <strong>我不能接受</strong>打在弹幕里）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">100</span> * <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">int</span> batch = <span class="number">1</span>;</span><br><span class="line">        ThreadPoolExecutor pools = </span><br><span class="line">				(ThreadPoolExecutor) Executors.newFixedThreadPool(batch);</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; batch; j ++)&#123;</span><br><span class="line">                pools.execute(semaphore::release);</span><br><span class="line">            &#125;</span><br><span class="line">            semaphore.acquire(batch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我不能接受，但是又要保证getRange阶段尽可能并发读取，于是乎我将思路转向了预读取，方法与Page Cache预读类似，举个栗子：当getRange读第0 ~ 10条数据的时候，从线程池中取个线程预读取第10 ~ 20条数据，并将这些数据存储在缓存块中，实际测试中，足够多的PMem缓存块使我们不用担心缓存池匮乏的问题。</p>
<h3 id="顺带一提"><a class="header-anchor" href="#顺带一提">¶</a>顺带一提</h3>
<ul>
<li>评测阶段线程数量不固定，好在所有线程几乎同时执行，所以在写入时阻塞一段时间获取到线程数量，之后再对其进行分组。</li>
<li>每个线程要持续运行，所以将线程内数据存入ThreadLocal中，并尽可能复用。</li>
<li>数据格式中的offset或许可以拿掉，每条记录可以省去4 Byte的空间。</li>
<li>两个方法的入参中，Topic的类型为String，但是格式固定为TopicN，可以搞个超大switch方法将其转为int类型，方便之后的存储与读取。</li>
</ul>
<h2 id="结束"><a class="header-anchor" href="#结束">¶</a>结束</h2>
<p>不知不觉，比赛已经结束，写这篇文章的时候明天就要上交的PPT还未开工，这次比赛收获很多，遗憾也不少，收获了很多卷友，遗憾自己未能如心。</p>
<p>从第一个方案出分的惊喜若狂到优化过程中的绞尽脑汁，每一秒的进步都带来了无与伦比的成就感。从为了给女朋友买个电瓶车代步的决心下定开始，仿佛就以注定要在这条道路上一卷无前。</p>
<p>来年，希望张三再发一次橙图（也不一定是橙色），到时候如果我心有余力，肯定很快点进来，然后一键三连。</p>
<p>仓库地址：<a href="https://github.com/ainilili/tianchi-race-2021" target="_blank" rel="noopener">https://github.com/ainilili/tianchi-race-2021</a></p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://github.com/torvalds/linux/tree/master/fs/ext4" target="_blank" rel="noopener">Ext4</a></li>
<li><a href="https://item.jd.com/13127464.html" target="_blank" rel="noopener">持久内存架构与工程实践</a></li>
<li><a href="https://item.jd.com/12367097.html" target="_blank" rel="noopener">深入浅出SSD - 固态存储核心技术原理与实战</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/01/Round-1C-2021-Code-Jam-2021-Closest-Pick/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/01/Round-1C-2021-Code-Jam-2021-Closest-Pick/" itemprop="url">Round 1C 2021 - Code Jam 2021 -  Closest Pick </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-01T19:59:00+08:00">
                2021-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原题地址: <a href="https://codingcompetitions.withgoogle.com/codejam/round/00000000004362d7/00000000007c0f00#problem" target="_blank" rel="noopener">传送门</a></p>
<h3 id="题解"><a class="header-anchor" href="#题解">¶</a>题解</h3>
<p>从题目中可以得知，要想赢，必须满足以下规则：</p>
<ul>
<li>1.不能与已选号码重复</li>
<li>2.所选号码周围的其他号码尽可能未被选中</li>
</ul>
<p>第一个规则很好理解，第二个规则这里解释一下，也是思路的核心。如果要想赢，需要离中奖号码最近，要想使胜率最大化，那么就要尽可能保证所选号码离所有其余未选号码的距离尽可能大于它们到已选号码，故而，当所选号码周围未选号码最多时，就是最大的胜率。</p>
<p>所以，这题的本质为寻找已选号码有序情况下的前两个最大的间隔，再计算分别计算两个间隔中能保证赢的号码数，再除以号码可选范围即为胜率，分情况考虑，记排序后的已选号码集合为arr，号码可选范围为k，已选号码总数为n：</p>
<ul>
<li>开头间隔1 ~ arr[0]和结尾间隔k - arr[n - 1]可赢号码数为当前间隔长度</li>
<li>两个已选号码之间的间隔如果为i，此时又要分两种情况考虑：
<ul>
<li>如果同一个间隔中同时选择两个号码，那么可赢号码数量为当前间隔长度</li>
<li>如果同一个间隔中只选择一个号码，那么可盈号码数量为interval / 2 + interval % 2</li>
</ul>
</li>
</ul>
<h3 id="golang解决"><a class="header-anchor" href="#golang解决">¶</a>Golang解决</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">	inputs := readInts()</span><br><span class="line">	n, k, arr := inputs[<span class="number">0</span>], inputs[<span class="number">1</span>], readInts()</span><br><span class="line">	sort.Ints(arr)</span><br><span class="line">	max1, max2 := arr[<span class="number">0</span>] - <span class="number">1</span>, k - arr[n - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> max2 &gt; max1 &#123;</span><br><span class="line">		max2, max1 = max1, max2</span><br><span class="line">	&#125;</span><br><span class="line">	maxInterval := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i ++ &#123;</span><br><span class="line">		interval := arr[i] - arr[i - <span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> interval &gt; <span class="number">0</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> interval &gt; maxInterval &#123;</span><br><span class="line">				maxInterval = interval</span><br><span class="line">			&#125;</span><br><span class="line">			interval = interval / <span class="number">2</span> + interval % <span class="number">2</span></span><br><span class="line">			<span class="keyword">if</span> interval &gt; max1 &#123;</span><br><span class="line">				max2, max1 = max1, interval</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> interval &gt; max2&#123;</span><br><span class="line">				max2 = interval</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(max(max1 + max2, maxInterval)) / <span class="keyword">float64</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/14/Google-Code-Jam-Round-1A-2021-Rabbit-House/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/14/Google-Code-Jam-Round-1A-2021-Rabbit-House/" itemprop="url">Round 1A 2021 - Code Jam 2021 -  Append Sort</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-14T21:37:00+08:00">
                2021-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原题地址: <a href="https://codingcompetitions.withgoogle.com/codejam/round/000000000043585d/00000000007549e5" target="_blank" rel="noopener">传送门</a></p>
<h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3>
<p>题目要求是对于输入的<code>X1,X2,…,XN</code>，求至少在每个数字后方增加多少个的<code>0-9</code>来保证<code>X1,X2,…,XN</code>的递增顺序。</p>
<p>举个例子，输入集为<code>98,9,8</code>，很明显当前顺序不是递增的，如果要保证顺序递增，需要在保证数组第二个元素大于第一个元素，第三个元素大于第二个元素。在不考虑题目中添加位数数量限制的情况下，<code>98,900,8000</code>这种通过保证每个元素之间总位数差为1的方案也是蛮不错的，但是如果要求增加尽可能少的位数来达到题目要求，最佳方案为<code>98,99,900</code>，也就是说我们要做到尽可能保证后一个元素的值尽可能接近前一个元素的值。</p>
<p>再举个例子，输入集为<code>1,1,1,1,1,1,1,1,1,1,1,1,1,1</code>，那么补全后的结果应该为<code>1 10 11 12 13 14 15 16 17 18 19 100 101 102</code>。</p>
<p>另外需要注意，此题有两个测试集，Test1还好，每次输入集的<code>X</code>数量以及范围都比较小，用<code>int</code>完全可以搞定，但是对于Test2来说，int不一定能够满足，当<code>X</code>的最大值为<code>10^9</code>，<code>N</code>为100时，在极端情况下（前一个元素总是比后一个元素大），最终补全后的结果的位数最大为<code>10 + 100 - 1 = 109</code>位，此时用int将会溢出导致结果错误，可以通过使用bigint或者自己将大数按位拆位数组来避免溢出的问题！</p>
<h3 id="solve"><a class="header-anchor" href="#solve">¶</a>Solve</h3>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> in = bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inputs := readInts(in)</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	nums := readInts(in)</span><br><span class="line">	preMark := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">110</span>)</span><br><span class="line">	nextMark := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">110</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputs[<span class="number">0</span>]; i ++&#123;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span>&#123;</span><br><span class="line">			markFlush(preMark, nums[i])</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		preL := markLen(preMark)</span><br><span class="line">		markFlush(nextMark, nums[i])</span><br><span class="line">		nextL := markLen(nextMark)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> preL &gt; nextL &#123;</span><br><span class="line">			diff := preL - nextL</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; nextL; j ++ &#123;</span><br><span class="line">				pv := preMark[j]</span><br><span class="line">				nv := nextMark[j]</span><br><span class="line">				<span class="keyword">if</span> nv &gt; pv &#123;</span><br><span class="line">					<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; diff; k ++&#123;</span><br><span class="line">						nextMark[nextL + k] = <span class="number">0</span></span><br><span class="line">					&#125;</span><br><span class="line">					count += diff</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span> nv &lt; pv &#123;</span><br><span class="line">					<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; diff + <span class="number">1</span>; k ++&#123;</span><br><span class="line">						nextMark[nextL + k] = <span class="number">0</span></span><br><span class="line">					&#125;</span><br><span class="line">					count += diff + <span class="number">1</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span> j == nextL - <span class="number">1</span>&#123;</span><br><span class="line">					<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; diff; k ++&#123;</span><br><span class="line">						nextMark[nextL + k] = preMark[nextL + k]</span><br><span class="line">					&#125;</span><br><span class="line">					count += diff</span><br><span class="line">					<span class="keyword">for</span> k := preL - <span class="number">1</span>; k &gt; nextL - <span class="number">1</span>; k --&#123;</span><br><span class="line">						nextMark[k] ++</span><br><span class="line">						<span class="keyword">if</span> nextMark[k] &lt; <span class="number">10</span>&#123;</span><br><span class="line">							<span class="keyword">break</span></span><br><span class="line">						&#125;</span><br><span class="line">						nextMark[k] = <span class="number">0</span></span><br><span class="line">						<span class="keyword">if</span> k == nextL &#123;</span><br><span class="line">							nextMark[preL] = <span class="number">0</span></span><br><span class="line">							count ++</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> preL == nextL&#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; preL; j ++ &#123;</span><br><span class="line">				pv := preMark[j]</span><br><span class="line">				nv := nextMark[j]</span><br><span class="line">				<span class="keyword">if</span> nv &gt; pv &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> nv &lt; pv || (nv == pv &amp;&amp; j == preL - <span class="number">1</span>)&#123;</span><br><span class="line">					count ++</span><br><span class="line">					nextMark[nextL] = <span class="number">0</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">copy</span>(preMark, nextMark)</span><br><span class="line">	&#125;</span><br><span class="line">	res = <span class="built_in">append</span>(res, count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markLen</span><span class="params">(mark []<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; count &lt; <span class="built_in">len</span>(mark); count++ &#123;</span><br><span class="line">		<span class="keyword">if</span> mark[count] == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markFlush</span><span class="params">(mark []<span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	l := numLen(num)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mark); i ++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; l &#123;</span><br><span class="line">			mark[i] = num / pow(<span class="number">10</span>, l - i - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			mark[i] = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numLen</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> num &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		num = num / <span class="number">10</span></span><br><span class="line">		count ++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	t := readInts(in)[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t; i ++ &#123;</span><br><span class="line">		solve()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Case #%d: %d\n"</span>, i + <span class="number">1</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline</span><span class="params">(in *bufio.Reader)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	line, _ := in.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">	<span class="keyword">return</span> line[<span class="number">0</span>:<span class="built_in">len</span>(line) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readInts</span><span class="params">(in *bufio.Reader)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">	line := readline(in)</span><br><span class="line">	arr := strings.Split(line, <span class="string">" "</span>)</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		v, _ := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">		res = <span class="built_in">append</span>(res, <span class="keyword">int</span>(v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/22/Kick-Start-Round-A-2021-Rabbit-House/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/22/Kick-Start-Round-A-2021-Rabbit-House/" itemprop="url">Kick Start Round A 2021 -  Rabbit House</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-22T12:33:00+08:00">
                2021-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原题地址: <a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cb14" target="_blank" rel="noopener">传送门</a></p>
<h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3>
<p>对于英文弱鸡的笔者，这道题着实看了很久才看懂题意，同样在一个二维平面内存在着<code>R * C</code>的格子，且每个格子都会有<code>0≤ Gi,j ≤2*10^6</code>各盒子，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 2 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>上述表示R为3，C为3的格子，中间格子的盒子数量为2，其余格子盒子数量为0。</p>
<p>描述到此为止，最终问题是求输入的R*C的格子中，如果要保证每个格子与相邻格子的盒子数量差在1以内，需要在当前规格的基础上，至少增加多少个盒子？</p>
<p>因为最终要保证整个平面内，所有的格子高度差绝对值 &lt;= 1，所以应该从最高的格子开始，让其相邻格子条件，之后除去当前格子，再取剩下格子中最高的格子循环处理，直到当前最高的格子高度为1时结束循环，将新增的盒子数作为答案输出。</p>
<p>分析后的问题转化为将格子从高到低排列，并优先取出最高的格子做处理，并且格子的高度排列是会随着处理过程发生变化，所以使用优先队列处理之！</p>
<h3 id="solve"><a class="header-anchor" href="#solve">¶</a>Solve</h3>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> in = bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inputs := readInts(in)</span><br><span class="line">	r := inputs[<span class="number">0</span>]</span><br><span class="line">	c := inputs[<span class="number">1</span>]</span><br><span class="line">	grid := <span class="built_in">make</span>([][]<span class="keyword">int</span>, r)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i ++ &#123;</span><br><span class="line">		grid[i] = readInts(in)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nodes := &amp;nodes&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i ++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; c; j++ &#123;</span><br><span class="line">			heap.Push(nodes, node&#123;</span><br><span class="line">				val: grid[i][j],</span><br><span class="line">				x: j,</span><br><span class="line">				y: i,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ;;&#123;</span><br><span class="line">		<span class="keyword">if</span> nodes.Len() == <span class="number">0</span>&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		n := heap.Pop(nodes).(node)</span><br><span class="line">		<span class="keyword">if</span> n.val != grid[n.y][n.x] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n.x &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> n.val - grid[n.y][n.x - <span class="number">1</span>] &gt; <span class="number">1</span>&#123;</span><br><span class="line">				m += n.val - grid[n.y][n.x - <span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">				grid[n.y][n.x - <span class="number">1</span>] = n.val - <span class="number">1</span></span><br><span class="line">				heap.Push(nodes, node&#123;</span><br><span class="line">					val: grid[n.y][n.x - <span class="number">1</span>],</span><br><span class="line">					x: n.x - <span class="number">1</span>,</span><br><span class="line">					y: n.y,</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n.x &lt; c <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> n.val - grid[n.y][n.x + <span class="number">1</span>] &gt; <span class="number">1</span>&#123;</span><br><span class="line">				m += n.val - grid[n.y][n.x + <span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">				grid[n.y][n.x + <span class="number">1</span>] = n.val - <span class="number">1</span></span><br><span class="line">				heap.Push(nodes, node&#123;</span><br><span class="line">					val: grid[n.y][n.x + <span class="number">1</span>],</span><br><span class="line">					x: n.x + <span class="number">1</span>,</span><br><span class="line">					y: n.y,</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n.y &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> n.val - grid[n.y - <span class="number">1</span>][n.x] &gt; <span class="number">1</span>&#123;</span><br><span class="line">				m += n.val - grid[n.y - <span class="number">1</span>][n.x] - <span class="number">1</span></span><br><span class="line">				grid[n.y - <span class="number">1</span>][n.x] = n.val - <span class="number">1</span></span><br><span class="line">				heap.Push(nodes, node&#123;</span><br><span class="line">					val: grid[n.y - <span class="number">1</span>][n.x],</span><br><span class="line">					x: n.x,</span><br><span class="line">					y: n.y - <span class="number">1</span>,</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n.y &lt; r - <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> n.val - grid[n.y + <span class="number">1</span>][n.x] &gt; <span class="number">1</span>&#123;</span><br><span class="line">				m += n.val - grid[n.y + <span class="number">1</span>][n.x] - <span class="number">1</span></span><br><span class="line">				grid[n.y + <span class="number">1</span>][n.x] = n.val - <span class="number">1</span></span><br><span class="line">				heap.Push(nodes, node&#123;</span><br><span class="line">					val: grid[n.y + <span class="number">1</span>][n.x],</span><br><span class="line">					x: n.x,</span><br><span class="line">					y: n.y + <span class="number">1</span>,</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res = <span class="built_in">append</span>(res, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	t := readInts(in)[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t; i ++ &#123;</span><br><span class="line">		solve()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Case #%d: %d\n"</span>, i + <span class="number">1</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline</span><span class="params">(in *bufio.Reader)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	line, _ := in.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">	<span class="keyword">return</span> line[<span class="number">0</span>:<span class="built_in">len</span>(line) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readInts</span><span class="params">(in *bufio.Reader)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">	line := readline(in)</span><br><span class="line">	arr := strings.Split(line, <span class="string">" "</span>)</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		v, _ := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">		res = <span class="built_in">append</span>(res, <span class="keyword">int</span>(v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">	x <span class="keyword">int</span></span><br><span class="line">	y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodes []node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *nodes)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(*t) <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *nodes)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (*t)[i].val &gt;= (*t)[j].val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *nodes)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	(*t)[i], (*t)[j] = (*t)[j], (*t)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *nodes)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*t = <span class="built_in">append</span>(*t, x.(node))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *nodes)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*t)</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		x := (*t)[n<span class="number">-1</span>]</span><br><span class="line">		*t = (*t)[:n<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *nodes)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*t)</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (*t)[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/22/Kick-Start-Round-A-2021-L-Shaped-Plots/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/22/Kick-Start-Round-A-2021-L-Shaped-Plots/" itemprop="url">Kick Start Round A 2021 -  L Shaped Plots </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-22T04:01:00+08:00">
                2021-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原题地址: <a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c509" target="_blank" rel="noopener">传送门</a></p>
<h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3>
<p>在二维坐标系中由很多坐标点组成段，段的最小长度为2，且段只有x轴（横轴）和y轴（纵轴）之分，求由两个段组成，垂直有共同顶点，且长边是短边两倍的组合数量。</p>
<p>输入集是一个二维数组，要求中的两个线段互相垂直，这里可以分析出组合中的两个线段一个在x轴一个在y轴。一种思路是通过遍历二维数组得到x和y轴所有的段，再对每个段的端点做索引，再做dfs求组合数，不过这种简单的思路在Test2会出现超时或内存溢出的错误，所以要换一种更简单的思路。</p>
<p>个人解决思路是先对x或y任意维度做head的索引（y轴由上到下，head为上顶点，x轴head为左顶点），例如先对y轴所有段的head做索引，这里直接使用二维数组，假设y轴段的索引定义为二维数组<code>indexs = [1000][1000]int</code>, indexs第一层下标为x轴坐标，第二层下标为y轴坐标，值为段的长度。之后再遍历获取所有的x轴段，对于x轴的每个段，取其对应的head和tail坐标以及长度len，通过枚举所有满足的y轴坐标值：</p>
<ul>
<li>y1 (head.x, head.y - （len/2） + 1)</li>
<li>y2 (head.x, head.y)</li>
<li>y3 (head.x, head.y - （len*2） + 1)</li>
<li>y4 (tail.x, tail.y - （len/2） + 1)</li>
<li>y5 (tail.x, tail.y)</li>
<li>y6 (tail.x, tail.y - （len*2） + 1)</li>
</ul>
<p>(y1和y4只有当len为偶数且大于等于4的时候才成立)<br>
之后通过得到的y轴坐标去检索indexs，如果存在则判断对应段的长度是否满足与当前x轴段长的规则，如果满足则count ++，所有x轴段匹配完毕，输出count为结果值。</p>
<h3 id="slove"><a class="header-anchor" href="#slove">¶</a>Slove</h3>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> in = bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inputs := readInts(in)</span><br><span class="line">	r := inputs[<span class="number">0</span>]</span><br><span class="line">	c := inputs[<span class="number">1</span>]</span><br><span class="line">	grid := <span class="built_in">make</span>([][]<span class="keyword">int</span>, r)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i ++ &#123;</span><br><span class="line">		grid[i] = readInts(in)</span><br><span class="line">	&#125;</span><br><span class="line">	cols := [<span class="number">1000</span>][<span class="number">1000</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c; i ++ &#123;</span><br><span class="line">		y := <span class="number">-1</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; r;	j ++  &#123;</span><br><span class="line">			<span class="keyword">if</span> grid[j][i] == <span class="number">1</span>&#123;</span><br><span class="line">				<span class="keyword">if</span> y == <span class="number">-1</span> &#123;</span><br><span class="line">					y = j</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> y != <span class="number">-1</span> &amp;&amp; (grid[j][i] != <span class="number">1</span>  || j == r - <span class="number">1</span>)&#123;</span><br><span class="line">				d := j - y</span><br><span class="line">				<span class="keyword">if</span> j == r - <span class="number">1</span> &amp;&amp; grid[j][i] == <span class="number">1</span>&#123;</span><br><span class="line">					d ++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> d &gt; <span class="number">1</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> di := <span class="number">0</span>; di &lt; d; di ++ &#123;</span><br><span class="line">						<span class="keyword">for</span> dj := di + <span class="number">1</span>; dj &lt; d;  dj ++&#123;</span><br><span class="line">							cols[i][y + di] = dj - di + <span class="number">1</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				y = <span class="number">-1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i ++ &#123;</span><br><span class="line">		x := <span class="number">-1</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; c;	j ++  &#123;</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="number">1</span>&#123;</span><br><span class="line">				<span class="keyword">if</span> x == <span class="number">-1</span> &#123;</span><br><span class="line">					x = j</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> x != <span class="number">-1</span> &amp;&amp;(grid[i][j] != <span class="number">1</span>  || j == c - <span class="number">1</span>)&#123;</span><br><span class="line">				d := j - x</span><br><span class="line">				<span class="keyword">if</span> j == c - <span class="number">1</span> &amp;&amp; grid[i][j] == <span class="number">1</span>&#123;</span><br><span class="line">					d ++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> d &gt; <span class="number">1</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> di := <span class="number">0</span>; di &lt; d; di ++ &#123;</span><br><span class="line">						<span class="keyword">for</span> dj := di + <span class="number">1</span>; dj &lt; d;  dj ++&#123;</span><br><span class="line">							hx := x + di</span><br><span class="line">							hy := i</span><br><span class="line">							tx := x + dj</span><br><span class="line">							ty := i</span><br><span class="line">							l := dj - di + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">							<span class="keyword">if</span> l % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; l &gt;= <span class="number">4</span>&#123;</span><br><span class="line">								chy := hy - l / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">								cty := ty - l / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">								<span class="keyword">if</span> chy &gt;= <span class="number">0</span> &#123;</span><br><span class="line">									<span class="keyword">if</span> n := cols[hx][chy]; n &gt;= l / <span class="number">2</span>&#123;</span><br><span class="line">										count ++</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">if</span> n := cols[hx][hy]; n &gt;= l / <span class="number">2</span> &#123;</span><br><span class="line">									count ++</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">if</span> cty &gt;= <span class="number">0</span> &#123;</span><br><span class="line">									<span class="keyword">if</span> n := cols[tx][cty]; n &gt;= l / <span class="number">2</span>&#123;</span><br><span class="line">										count ++</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">if</span> n := cols[tx][ty]; n &gt;= l / <span class="number">2</span> &#123;</span><br><span class="line">									count ++</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							chy := hy - l * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">							cty := ty - l * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">							<span class="keyword">if</span> chy &gt;= <span class="number">0</span> &#123;</span><br><span class="line">								<span class="keyword">if</span> n := cols[hx][chy]; n &gt;= l * <span class="number">2</span> &#123;</span><br><span class="line">									count ++</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> n := cols[hx][hy]; n &gt;= l * <span class="number">2</span> &#123;</span><br><span class="line">								count ++</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> cty &gt;= <span class="number">0</span> &#123;</span><br><span class="line">								<span class="keyword">if</span> n := cols[tx][cty]; n &gt;= l * <span class="number">2</span> &#123;</span><br><span class="line">									count ++</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> n := cols[tx][ty]; n &gt;= l * <span class="number">2</span> &#123;</span><br><span class="line">								count ++</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				x = <span class="number">-1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">append</span>(res, count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	t := readInts(in)[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t; i ++ &#123;</span><br><span class="line">		solve()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Case #%d: %d\n"</span>, i + <span class="number">1</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline</span><span class="params">(in *bufio.Reader)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	line, _ := in.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">	<span class="keyword">return</span> line[<span class="number">0</span>:<span class="built_in">len</span>(line) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readInts</span><span class="params">(in *bufio.Reader)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">	line := readline(in)</span><br><span class="line">	arr := strings.Split(line, <span class="string">" "</span>)</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		v, _ := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">		res = <span class="built_in">append</span>(res, <span class="keyword">int</span>(v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/22/Kick-Start-Round-A-2021-K-Goodness-String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/22/Kick-Start-Round-A-2021-K-Goodness-String/" itemprop="url">Kick Start Round A 2021 -  K-Goodness String</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-22T02:37:00+08:00">
                2021-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原题地址: <a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cca3#problem" target="_blank" rel="noopener">传送门</a></p>
<h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3>
<p>题意大概是当字符串对称位置的字母如果不相同则score加一分，输入字符串以及期望的score分数，求将当前字符串变动任意位置的字母使之score等于期望的socre。</p>
<p>其实就是求字符串对称位置字符不相同的数量，然后和期望score做差再取abs。</p>
<h3 id="slove"><a class="header-anchor" href="#slove">¶</a>Slove</h3>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> in = bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inputs := readInts(in)</span><br><span class="line">	n := inputs[<span class="number">0</span>]</span><br><span class="line">	k := inputs[<span class="number">1</span>]</span><br><span class="line">	str := readline(in)</span><br><span class="line">	s := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">		r := n - <span class="number">1</span> - i</span><br><span class="line">		<span class="keyword">if</span> r &lt;= i &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> str[i] != str[r] &#123;</span><br><span class="line">			s ++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	result := k - s</span><br><span class="line">	<span class="keyword">if</span> result &lt; <span class="number">0</span>&#123;</span><br><span class="line">		result = - result</span><br><span class="line">	&#125;</span><br><span class="line">	res = <span class="built_in">append</span>(res, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	t := readInts(in)[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t; i ++ &#123;</span><br><span class="line">		solve()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Case #%d: %d\n"</span>, i + <span class="number">1</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline</span><span class="params">(in *bufio.Reader)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	line, _ := in.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">	<span class="keyword">return</span> line[<span class="number">0</span>:<span class="built_in">len</span>(line) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readInts</span><span class="params">(in *bufio.Reader)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">	line := readline(in)</span><br><span class="line">	arr := strings.Split(line, <span class="string">" "</span>)</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		v, _ := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">		res = <span class="built_in">append</span>(res, <span class="keyword">int</span>(v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/如何设计并实现一个db连接池？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/如何设计并实现一个db连接池？/" itemprop="url">如何设计并实现一个db连接池？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-26T13:42:00+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="连接池的使命"><a class="header-anchor" href="#连接池的使命">¶</a>连接池的使命！</h2>
<p>无论是线程池还是db连接池，他们都有一个共同的特性：<strong>资源复用</strong>，在普通的场景中，我们使用一个连接，它的生命周期可能是这样的：<br>
<img src="https://user-gold-cdn.xitu.io/2019/5/24/16ae8d822d4ac11e?w=637&amp;h=168&amp;f=png&amp;s=4758" alt><br>
一个连接，从创建完毕到销毁，期间只被使用了一次（这里的一次是指在单个作用域内的使用），当周期结束，另外一个调用者仍然需要这个连接去做事，就要重复去经历这种生命周期。因为创建和销毁都是需要对应的服务消耗时间以及系统资源去处理的，这样不仅浪费了大量的系统资源，而且导致业务响应过程中都要花费部分时间去重复的创建和销毁，得不偿失，而连接池便被赋予了解决这种问题的使命！</p>
<h2 id="连接池需要做什么？"><a class="header-anchor" href="#连接池需要做什么？">¶</a>连接池需要做什么？</h2>
<p>顾名思义，连接池中的<strong>池</strong>字已经很生动形象的阐明了它的用意，它用将所有连接放入一个<code>&quot;池子&quot;</code>中统一的去控制连接的创建和销毁，和原始生命周期去对比，连接池多了以下特性：</p>
<ul>
<li>创建并不是真的创建，而是从池子中选出空闲连接。</li>
<li>销毁并不是真的销毁，而是将使用中的连接放回池中（逻辑关闭）。</li>
<li>真正的创建和销毁由线程池的特性机制来决定。</li>
</ul>
<p>因此，当使用连接池后，我们使用一个连接的生命周期将会演变成这样：<br>
<img src="https://user-gold-cdn.xitu.io/2019/5/24/16ae8fb43b0a3d13?w=588&amp;h=377&amp;f=png&amp;s=13088" alt></p>
<h2 id="分析计划"><a class="header-anchor" href="#分析计划">¶</a>分析计划</h2>
<p>通灵之术 - 传送门：<a href="https://github.com/ainilili/honeycomb" target="_blank" rel="noopener">https://github.com/ainilili/honeycomb</a>，DEMO为Java语言实现！</p>
<p>事前，我们需要点支烟分析一下时间一个连接池需要做哪些事情：</p>
<ul>
<li>保存连接的容器是必不可少的，另外，该容器也要支持连接的添加和移除功能，并保证线程安全。</li>
<li>我们需要因为要对连接的销毁做逻辑调整，我们需要重写它的<code>close</code>以及<code>isClosed</code>方法。</li>
<li>我们需要有个入口对连接池做管理，例如回收空闲连接。</li>
</ul>
<p>连接池不仅仅只是对<code>Connection</code>生命周期的控制，还应该加入一些特色，例如初始连接数，最大连接数，最小连接数、最大空闲时长以及获取连接的等待时长，这些我们也简单支持一下。</p>
<p>目标以明确，开始动工。</p>
<h3 id="连接池容器选型"><a class="header-anchor" href="#连接池容器选型">¶</a>连接池容器选型</h3>
<p>要保证线程安全，我们可以将目标瞄准在<code>JUC</code>包下的神通们，设我们想要的容器为<code>x</code>，那么<code>x</code>不仅需要满足基本的增删改查功能，而且也要提供获取超时功能，这是为了保证当池内长时间没有空闲连接时不会导致业务阻塞，即刻熔断。另外，<code>x</code>需要满足双向操作，这是为了连接池可以识别出饱和的空闲连接，方便回收操作。</p>
<p>综上所述，<code>LinkedBlockingDeque</code>是最合适的选择，它使用<code>InterruptibleReentrantLock</code>来保证线程安全，使用<code>Condition</code>来做获取元素的阻塞，另外支持双向操作。</p>
<p>另外，我们可以将连接池拆分为3个类型：</p>
<ul>
<li><strong>工作池</strong>：存放正在被使用的连接。</li>
<li><strong>空闲池</strong>：存放空闲连接。</li>
<li><strong>回收池</strong>：已经被回收（物理关闭）的连接。</li>
</ul>
<p>其中，<strong>工作池</strong>和<strong>回收池</strong>大可不必用双向对列，或许用单向队列或者<code>Set</code>都可以代替之：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;HoneycombConnection&gt; workQueue;</span><br><span class="line"><span class="keyword">private</span> LinkedBlockingDeque&lt;HoneycombConnection&gt; idleQueue;</span><br><span class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;HoneycombConnection&gt; freezeQueue;</span><br></pre></td></tr></table></figure>
<h3 id="connection的装饰"><a class="header-anchor" href="#connection的装饰">¶</a>Connection的装饰</h3>
<p>连接池的输出是<code>Connection</code>，它代表着一个db连接，上游服务使用它做完操作后，会直接调用它的<code>close</code>方法来释放连接，而我们必须做的是在调用者无感知的情况下改变它的关闭逻辑，当调用<code>close</code>的方法时，我们将它放回空闲队列中，保证其的可复用性！</p>
<p>因此，我们需要对原来的<code>Connection</code>做装饰，其做法很简单，但是很累，这里新建一个类来实现<code>Connection</code>接口，通过重写所有的方法来实现一个**“可编辑”**的<code>Connection</code>，我们称之为<code>Connection</code>的装饰者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneycombConnectionDecorator</span> <span class="keyword">implements</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Connection connection;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HoneycombConnectionDecorator</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    此处省略对方法实现的三百行代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，我们需要新建一个自己的<code>Connection</code>来继承这个装饰者，并重写相应的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneycombConnection</span> <span class="keyword">extends</span> <span class="title">HoneycombConnectionDecorator</span> <span class="keyword">implements</span> <span class="title">HoneycombConnectionSwitcher</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; <span class="keyword">do</span> some things &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123; <span class="keyword">do</span> some things &#125;    </span><br><span class="line">    </span><br><span class="line">    省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="datasource的重写"><a class="header-anchor" href="#datasource的重写">¶</a>DataSource的重写</h3>
<p><code>DataSource</code>是JDK为了更好的统合和管理数据源而定义出的一个规范，获取连接的入口，方便我们在这一层更好的扩展数据源（例如增加特殊属性），使我们的连接池的功能更加丰富，我们需要实现一个自己的<code>DataSource</code>能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneycombWrapperDatasource</span> <span class="keyword">implements</span> <span class="title">DataSource</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> HoneycombDatasourceConfig config;</span><br><span class="line">    省略其它方法的实现...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(config.getUrl(), config.getUser(), config.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(config.getUrl(), username, password);</span><br><span class="line">    &#125;</span><br><span class="line">    省略其它方法的实现...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们完成了对数据源的实现，但是这里获取连接的方式是物理创建，我们需要满足池化的目的，需要重写<code>HoneycombWrapperDatasource</code>中的连接获取逻辑，做法是创建一个新的类对父类方法重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneycombDataSource</span> <span class="keyword">extends</span> <span class="title">HoneycombWrapperDatasource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HoneycombConnectionPool pool;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        这里实现从pool中取出连接的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特性扩展"><a class="header-anchor" href="#特性扩展">¶</a>特性扩展</h3>
<p>在当前结构体系下，我们的连接池逐渐浮现出了雏形，但远远不够的是，我们需要在此结构下可以做自由的扩展，使连接池对连接的控制更加灵活，因此我们可以引入<strong>特性</strong>这个概念，它允许我们在其内部访问连接池，并对连接池做一系列的扩展操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFeature</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(HoneycombConnectionPool pool)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractFeature</code>抽象父类需要实现<code>doing</code>方法，我们可以在方法内部实现对连接池的控制，其中一个典型的例子就是对池中空闲连接左回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanerFeature</span> <span class="keyword">extends</span> <span class="title">AbstractFeature</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(HoneycombConnectionPool pool)</span> </span>&#123;</span><br><span class="line">        这里做空闲连接的回收</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="落实计划"><a class="header-anchor" href="#落实计划">¶</a>落实计划</h2>
<p>经过上述分析，要完成一个连接池，需要这些模块的配合，总体流程如下：<br>
<img src="https://user-gold-cdn.xitu.io/2019/5/26/16af28f6f668a3e6?w=754&amp;h=845&amp;f=png&amp;s=66582" alt></p>
<h3 id="第一步：设置数据源属性"><a class="header-anchor" href="#第一步：设置数据源属性">¶</a>第一步：设置数据源属性</h3>
<p>在初始化<code>DataSource</code>之前，我们需要将各属性设置进去，这里使用<code>HoneycombWrapperDatasource</code>中的<code>HoneycombDatasourceConfig</code>来承载各属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneycombDatasourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//db url</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//db user</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//db password</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//driver驱动</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化连接数，默认为2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> initialPoolSize = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大连接数，默认为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小连接数，默认为2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minPoolSize = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取连接时，最大等待时长，默认为60s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitTime = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大空闲时长，超出要被回收，默认为20s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxIdleTime = <span class="number">20</span> * <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//特性列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractFeature&gt; features;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoneycombDatasourceConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        features = <span class="keyword">new</span> ArrayList&lt;AbstractFeature&gt;(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    省略getter、setter....</span><br></pre></td></tr></table></figure>
<h3 id="第二步：初始化连接池"><a class="header-anchor" href="#第二步：初始化连接池">¶</a>第二步：初始化连接池</h3>
<p>设置好属性之后，我们需要完成连接池的初始化工作，在<code>HoneycombDataSource</code>的<code>init</code>方法中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//阻塞其他线程初始化操作，等待初始化完成</span></span><br><span class="line">    <span class="keyword">if</span>(initialStarted || ! (initialStarted = ! initialStarted)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(! initialFinished) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                INITIAL_LOCK.lock();</span><br><span class="line">                INITIAL_CONDITION.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                INITIAL_LOCK.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//config参数校验</span></span><br><span class="line">    config.assertSelf();</span><br><span class="line">    </span><br><span class="line">    Class.forName(getDriver());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例化线程池</span></span><br><span class="line">    pool = <span class="keyword">new</span> HoneycombConnectionPool(config);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化最小连接</span></span><br><span class="line">    Integer index = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; config.getInitialPoolSize(); i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((index =  pool.applyIndex()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pool.putLeisureConnection(createNativeConnection(pool), index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//触发特性</span></span><br><span class="line">    pool.touchFeatures();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//完成初始化并唤醒其他阻塞</span></span><br><span class="line">    initialFinished = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        INITIAL_LOCK.lock();</span><br><span class="line">        INITIAL_CONDITION.signalAll();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        INITIAL_LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步：创建初始连接"><a class="header-anchor" href="#第三步：创建初始连接">¶</a>第三步：创建初始连接</h3>
<p>在<code>init</code>的方法中，如果<code>initialPoolSize</code>大于0，会去创建指定数量的物理连接放入连接池中，创建数量要小于最大连接数<code>maxPoolSize</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HoneycombConnection <span class="title">createNativeConnection</span><span class="params">(HoneycombConnectionPool pool)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HoneycombConnection(<span class="keyword">super</span>.getConnection(), pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成初始化后，下一步就是获取连接。</p>
<h3 id="第四步：从空闲池获取"><a class="header-anchor" href="#第四步：从空闲池获取">¶</a>第四步：从空闲池获取</h3>
<p>我们之前将连接池分成了三个，它们分别是<strong>空闲池</strong>、<strong>工作池</strong>和<strong>回收池</strong>。</p>
<p>我们可以通过<code>HoneycombDataSource</code>的<code>getConnection</code>方法来获取连接，当我们需要获取时，首先考虑的是空闲池是否有空闲连接，这样可以避免创建和激活新的连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">//初始化连接池</span></span><br><span class="line">        init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HoneycombConnection cn = <span class="keyword">null</span>;</span><br><span class="line">    Integer index = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pool.assignable()) &#123;</span><br><span class="line">    	<span class="comment">//空闲池可分配，从空闲池取出</span></span><br><span class="line">        cn = pool.getIdleConnection();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pool.actionable()) &#123;</span><br><span class="line">    	<span class="comment">//回收池可分配，从回收池取出</span></span><br><span class="line">        cn = pool.getFreezeConnection();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((index =  pool.applyIndex()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//如果连接数未满，创建新的物理连接</span></span><br><span class="line">        cn = pool.putOccupiedConnection(createNativeConnection(pool), index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cn == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//如果无法获取连接，阻塞等待空闲池连接</span></span><br><span class="line">        cn = pool.getIdleConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cn.isClosedActive()) &#123;</span><br><span class="line">    	<span class="comment">//如果物理连接关闭，则获取新的连接</span></span><br><span class="line">        cn.setConnection(<span class="keyword">super</span>.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第五步：从回收池获取"><a class="header-anchor" href="#第五步：从回收池获取">¶</a>第五步：从回收池获取</h3>
<p>如果空闲池不可分配，那么说明连接供不应求，也许之前有些空闲连接已经被回收（物理关闭），那么我们在创建新连接之前，可以到回收池看一下是否存在已回收连接，如果存在直接取出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pool.actionable()) &#123;</span><br><span class="line">	<span class="comment">//回收池可分配，从回收池取出</span></span><br><span class="line">    cn = pool.getFreezeConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第六步：创建新的连接"><a class="header-anchor" href="#第六步：创建新的连接">¶</a>第六步：创建新的连接</h3>
<p>如果回收池也不可分配，此时要判断连接池连接数量是否已经达到最大连接，如果没有达到，创建新的物理连接并直接添加到工作池中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((index =  pool.applyIndex()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//如果连接数未满，创建新的物理连接，添加到工作池</span></span><br><span class="line">    cn = pool.putOccupiedConnection(createNativeConnection(pool), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第七步：等待空闲池的连接"><a class="header-anchor" href="#第七步：等待空闲池的连接">¶</a>第七步：等待空闲池的连接</h3>
<p>如果上述三种情况都不满足，那么只能从空闲池等待其他连接的释放：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cn == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//如果无法获取连接，阻塞等待空闲池连接</span></span><br><span class="line">    cn = pool.getIdleConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体逻辑封装在<code>HoneycombConnectionPool</code>的<code>getIdleConnection</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HoneycombConnection <span class="title">getIdleConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">//获取最大等待时间</span></span><br><span class="line">        <span class="keyword">long</span> waitTime = config.getMaxWaitTime();</span><br><span class="line">        <span class="keyword">while</span>(waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> beginPollNanoTime = System.nanoTime();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//设置超时时间，阻塞等待其他连接的释放</span></span><br><span class="line">            HoneycombConnection nc = idleQueue.poll(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span>(nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            	<span class="comment">//状态转换</span></span><br><span class="line">                <span class="keyword">if</span>(nc.isClosed() &amp;&amp; nc.switchOccupied() &amp;&amp; working(nc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> timeConsuming = (System.nanoTime() - beginPollNanoTime) / (<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//也许在超时时间内获取到了连接，但是状态转换失败，此时刷新超时时间</span></span><br><span class="line">            waitTime -= timeConsuming;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取连接超时"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第八步：激活连接"><a class="header-anchor" href="#第八步：激活连接">¶</a>第八步：激活连接</h3>
<p>最后，判断一下连接是否被物理关闭，如果是，我们需要打开新的连接替换已经被回收的连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cn.isClosedActive()) &#123;</span><br><span class="line">	<span class="comment">//如果物理连接关闭，则获取新的连接</span></span><br><span class="line">    cn.setConnection(<span class="keyword">super</span>.getConnection());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连接的回收"><a class="header-anchor" href="#连接的回收">¶</a>连接的回收</h3>
<p>如果在某段时间内我们的业务量剧增，那么需要同时工作的连接将会很多，之后过了不久，我们的业务量下降，那么之前已经创建的连接明显饱和，这时就需要我们对其进行回收，我们可以通过<code>AbstractFeature</code>入口操作连接池。</p>
<p>对于回收这个操作，我们通过<code>CleanerFeature</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanerFeature</span> <span class="keyword">extends</span> <span class="title">AbstractFeature</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(CleanerFeature<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CleanerFeature</span><span class="params">(<span class="keyword">boolean</span> enable, <span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//enable表示是否启用</span></span><br><span class="line">       <span class="comment">//interval表示扫描间隔</span></span><br><span class="line">       <span class="keyword">super</span>(enable, interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(HoneycombConnectionPool pool)</span> </span>&#123;</span><br><span class="line">        LinkedBlockingDeque&lt;HoneycombConnection&gt; idleQueue = pool.getIdleQueue();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//回收扫描间隔</span></span><br><span class="line">                    	Thread.sleep(interval);</span><br><span class="line">                        </span><br><span class="line">                    	<span class="comment">//回收时，空闲池上锁</span></span><br><span class="line">                        <span class="keyword">synchronized</span> (idleQueue) &#123;</span><br><span class="line">                            logger.debug(<span class="string">"Cleaner Model To Start &#123;&#125;"</span>, idleQueue.size());</span><br><span class="line">                            <span class="comment">//回收操作</span></span><br><span class="line">                            idleQueue.stream().filter(c -&gt; &#123; <span class="keyword">return</span> c.idleTime() &gt; pool.getConfig().getMaxIdleTime(); &#125;).forEach(c -&gt; &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span>(! c.isClosedActive() &amp;&amp; c.idle()) &#123;</span><br><span class="line">                                        c.closeActive();</span><br><span class="line">                                        pool.freeze(c);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125; </span><br><span class="line">                            &#125;);</span><br><span class="line">                            logger.debug(<span class="string">"Cleaner Model To Finished &#123;&#125;"</span>, idleQueue.size());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Cleaner happended error"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的操作很简单，对空闲池加锁，扫描所有连接，释放空闲时间超过最大空闲时间设置的连接，其实这里只要知道当前连接的空闲时长就一目了然了，我们在连接放入空闲池时候去刷新他的空闲时间点，那么当前的空闲时长就等于当前时间减去空闲开始时间：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idleTime = nowTime - idleStartTime</span><br></pre></td></tr></table></figure>
<p>在切换状态为空闲时刷新空闲开始时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">switchIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, statusOffset, status, ConnectionStatus.IDLE) &amp;&amp; flushIdleStartTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试一下"><a class="header-anchor" href="#测试一下">¶</a>测试一下</h2>
<p>体验成果的最快途径就是投入使用，这里搞一个单元测试体验一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadPoolExecutor tpe = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcurrence</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    HoneycombDataSource dataSource = <span class="keyword">new</span> HoneycombDataSource();</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;transformedBitIsBoolean=true&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;serverTimezone=Asia/Shanghai"</span>);</span><br><span class="line">    dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"root"</span>);</span><br><span class="line">    dataSource.setDriver(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">    dataSource.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line">    dataSource.setInitialPoolSize(<span class="number">10</span>);</span><br><span class="line">    dataSource.setMinPoolSize(<span class="number">10</span>);</span><br><span class="line">    dataSource.setMaxWaitTime(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    dataSource.setMaxIdleTime(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">    dataSource.addFeature(<span class="keyword">new</span> CleanerFeature(<span class="keyword">true</span>, <span class="number">5</span> * <span class="number">1000</span>));</span><br><span class="line">    </span><br><span class="line">    test(dataSource, <span class="number">10000</span>);</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(DataSource dataSource, <span class="keyword">int</span> count)</span> <span class="keyword">throws</span> SQLException, InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        tpe.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HoneycombConnection connection = (HoneycombConnection) dataSource.getConnection();</span><br><span class="line">                Statement s = connection.createStatement();</span><br><span class="line">                s.executeQuery(<span class="string">"select * from test limit 1"</span>);</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                cdl.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cdl.await();</span><br><span class="line">    tpe.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PC配置：<strong>Intel® Core™ i5-8300H CPU @ 2.30GHz 2.30 GHz 4核8G 512SSD</strong></p>
<p>10000次查询，耗时：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">938</span> ms</span><br></pre></td></tr></table></figure>
<p>结束语：再次召唤传送门：<a href="https://github.com/ainilili/honeycomb" target="_blank" rel="noopener">https://github.com/ainilili/honeycomb</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/深入JAVA8的HashMap实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/深入JAVA8的HashMap实现原理/" itemprop="url">深入JAVA8的HashMap实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-25T19:42:00+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引导"><a class="header-anchor" href="#引导">¶</a>引导</h2>
<p>在了解<code>HashMap</code>之前，我们应该先明白两个概念：<code>Hash</code>和<code>Map</code>，这可以帮助我们更容易了解<code>HashMap</code>的运行原理。</p>
<p>那么何为<code>Hash</code>，又何为<code>Map</code>呢？</p>
<h3 id="hash"><a class="header-anchor" href="#hash">¶</a>Hash</h3>
<p>之前写过一篇关于Hash的文章 <a href="/zh-cn/java/data-structure/hash.md">Hash</a></p>
<h3 id="map"><a class="header-anchor" href="#map">¶</a>Map</h3>
<p>Map是一种<code>K-V</code>形式的数据结构，一个唯一的key，会唯一对应一个value。也就是说，在Map容器里不允许两个一模一样的key。</p>
<p>一个简单的Map结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;key1&quot;:&quot;value1&quot;,</span><br><span class="line">  &quot;key2&quot;:&quot;value2&quot;,</span><br><span class="line">  &quot;key3&quot;:&quot;value3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这种数据结构，并且Map会对外提供一些方法来实现对内部数据的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V put(K key, V value)</span><br><span class="line">V get(Object key)</span><br><span class="line">V remove(Object key)</span><br><span class="line">boolean containsKey(Object key)</span><br></pre></td></tr></table></figure>
<p>可见Map对于我们操作<code>K-V</code>形式的数据非常方便，实现的方式有很多，最简单粗暴的实现方式是使用<code>List</code>来存储每一个<code>K-V</code>组对，对于每种方法的实现只需要暴力循环碰撞即可，对于少量数据这种做法未必不可，如果数据量庞大之千万，我们就要换一种更加高效，速度更快的实现方式：<code>HashMap</code>。</p>
<h2 id="hashmap"><a class="header-anchor" href="#hashmap">¶</a>HashMap</h2>
<p>Map在Java中的实现有很多，<code>HashMap</code>便是其中之一，在<code>JDK</code>漫长的版本更新中，<code>HashMap</code>的实现也是在不断的更新着：</p>
<ul>
<li><strong>&lt;=JDK1.7</strong>：Table数组 + Entry链表</li>
<li><strong>&gt;=JDK1.8</strong>：Table数组 + Entry链表/红黑树</li>
</ul>
<p>本文我们跳过JDK1.7的实现，来看一下1.8中<code>HashMap</code>源码所带来的魅力冲击！</p>
<h3 id="实现原理"><a class="header-anchor" href="#实现原理">¶</a>实现原理</h3>
<p>对于各个版本的<code>HashMap</code>实现原理，主线流程都是一成不变的：</p>
<p><img src="https://github.com/ainilili/snail/blob/master/docs/images/hashmap-1.8-1-1.jpg?raw=true" alt="hashmap原理流程图"></p>
<p>这里有两个数据结构需要我们知道：</p>
<ul>
<li><strong>Table</strong>：哈希表，存放Node元素。</li>
<li><strong>Node</strong>：结点元素，存放<code>K-V</code>组对信息，其结构是一个链表/红黑树。</li>
</ul>
<p>另外，在HashMap内部有一些关键属性我们也要了解一下：</p>
<ul>
<li><strong>DEFAULT_INITIAL_CAPACITY</strong>：Table数组初始长度，默认为<code>1 &lt;&lt; 4</code>，<code>2^4</code> = 16。</li>
<li><strong>MAXIMUM_CAPACITY</strong>：Table数组最高长度，默认为<code>1 &lt;&lt; 30</code>，<code>2^30</code> = 1073741824。</li>
<li><strong>DEFAULT_LOAD_FACTOR</strong>：负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将会扩容，默认为0.75。</li>
<li><strong>TREEIFY_THRESHOLD</strong>：树化阈值，当单个Table内Node数量超过该值，则会将链表转化为红黑树，默认为8。</li>
<li><strong>UNTREEIFY_THRESHOLD</strong>：链化阈值，当扩容期间单个Table内Entry数量小于该值，则将红黑树转化为链表，默认为6。</li>
<li><strong>MIN_TREEIFY_CAPACITY</strong>：最小树化阈值，当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</li>
<li><strong>size</strong>：Table数组当前所有元素数。</li>
<li><strong>threshold</strong>：下次扩容的阈值（数组长度 * 负载因子）</li>
</ul>
<p>HashMap的内部有着一个Table数组，而这个数组的初始长度为<code>DEFAULT_INITIAL_CAPACITY</code>参数值，Table数组存放的元素类型就是Node，它是一个单向链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//key的hash值</span></span><br><span class="line">  <span class="keyword">final</span> K key;  <span class="comment">//key</span></span><br><span class="line">  V value;  <span class="comment">//value</span></span><br><span class="line">  Node&lt;K,V&gt; next; <span class="comment">//下一个结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Table中存的Node元素相当于链表的<code>header</code>，<code>next</code>指向下一个结点，而这种链式结构的存在正是为了解决<code>hash冲突</code>：</p>
<blockquote>
<p><strong>hash冲突</strong>：两个元素的经过Hash散列之后分在同一个组内，我们将之解释为Hash冲突</p>
</blockquote>
<p>在JDK1.7之前的版本，hash冲突的解决方法是将被冲突的Node结点放于一个链表中，而Table中的元素则是链头，当然在JDK1.8中，当Table中链长超过<code>TREEIFY_THRESHOLD</code>阈值后，将会将链表转变为红黑树的实现<code>TreeNode</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">  TreeNode&lt;K,V&gt; left;</span><br><span class="line">  TreeNode&lt;K,V&gt; right;</span><br><span class="line">  TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">  boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生hash冲突的Node不断变多，那么这个链将会越来越长，那么遍历碰撞key时的耗时就会不断增加，这也就直接导致了性能的不足，从JDK1.8开始，HashMap对于单个Table中的Node超出某个阈值时，将会开始树化操作（链表转化为红黑树），这对于搜索的性能将会有很大的提升，而插入和删除的操作所带来的性能影响微乎其微。</p>
<h3 id="put方法"><a class="header-anchor" href="#put方法">¶</a>put方法</h3>
<p>在<code>HashMap</code>的内部会有一个Table数组，这个数组的当前长度就是我们要实现映射的目标范围，当我们执行<code>put</code>方法时，<code>key</code>和<code>value</code>要经历这些事情：</p>
<ul>
<li>通过<code>Hash</code>散列获取到对应的Table</li>
<li>遍历Table下的Node结点，做更新/添加操作</li>
<li>扩容检测</li>
</ul>
<p>具体实现我们可以根据源码来详细了解一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// HashMap的懒加载策略，当执行put操作时检测Table数组初始化。</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//通过``Hash``函数获取到对应的Table，如果当前Table为空，则直接初始化一个新的Node并放入该Table中。</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//输入的key命中了当前Table的首元素，直接更新。</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果当前Node类型为TreeNode，调用``putTreeVal``方法。</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是TreeNode，则就是链表，遍历并与输入key做命中碰撞。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果当前Table中不存在当前key，则添加。</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//超过了``TREEIFY_THRESHOLD``则转化为红黑树。</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">//做命中碰撞，使用hash、内存和equals同时判断（不同的元素hash可能会一致）。</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果命中不为空，更新操作。</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//扩容检测。</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于其过程中的关于Node链表和红黑树的转换过程我们可以暂时屏蔽掉，那么整个流程并不是很绕，那么我们继续深入的来看一下HashMap的扩容实现。</p>
<h3 id="resize方法"><a class="header-anchor" href="#resize方法">¶</a>resize方法</h3>
<p>HashMap的扩容大致的实现是将老Table数组中所有的Entry取出来，重新对其hashcode做<code>Hash</code>散列到新的新的Table之中，也就是一个<code>re-put</code>的过程，具体还是通过源码来讲解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//保留老的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果之前的容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果超出最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//扩容阈值为int最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则计算扩容后的阈值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果之前的容量等于0，并且之前的阈值大于零，则新的hash表长度就等于它</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;              </span><br><span class="line">        <span class="comment">// 初始阈值为零表示使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新的阈值为 0 ，就得用 新容量*加载因子 重计算一次</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//常见扩容后的hash表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">//A</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧的hash表，将之内部元素转移到新的hash表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果当前Table内只有一个元素，重新做hash散列并赋值</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//B</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//如果旧哈希表中这个位置的桶是树形结构，就要把新哈希表里当前桶也变成树形结构</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//保留旧哈希表桶中链表的顺序</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;  <span class="comment">//遍历当前Table内的Node，赋值给新的Table</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get方法"><a class="header-anchor" href="#get方法">¶</a>get方法</h3>
<p>在我们看完HashMap对于put方法的实现之后，get方法则显得简单易懂，其代码与put相近无几，主要差别是没有了扩容和添加/更新的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//判断hash表是否为空，表重读是否大于零并且当前key对应分布的表内是否有Node存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 检测第一个Node，命中则不需要在做do...while...循环</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//如果Table内是树形结构，则使用对应的检索方法</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">//如果是链表，则做while循环，直到命中或者遍历结束</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="containskey方法"><a class="header-anchor" href="#containskey方法">¶</a>containsKey方法</h3>
<p>根据get方法的结果是否为空就可以直到是否包含该key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    return getNode(hash(key), key) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove方法"><a class="header-anchor" href="#remove方法">¶</a>remove方法</h3>
<p>同样类似于put操作，首先会查找对应的key所在位置，如果为空，则不操作，反之，将之移除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//判断hash表是否为空，表重读是否大于零并且当前key对应分布的表内是否有Node存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 第一个Node命中</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//如果Table内是树形结构，则使用对应的检索方法</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">//如果是链表，则做while循环，直到命中或者遍历结束</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//如果命中到了对应的Node，则根据Node结构进行对应的移除操作</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">//修改hash表元素数</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为何线程不安全？"><a class="header-anchor" href="#为何线程不安全？">¶</a>为何线程不安全？</h2>
<p>看完了HashMap的实现之后，就该谈一谈它为什么存在线程安全问题！</p>
<h3 id="数据丢失"><a class="header-anchor" href="#数据丢失">¶</a>数据丢失</h3>
<p>首先，我们将目光放在put方法的实现中，假设有两个线程在同时进行put操作，对应的数据分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread-1： put(1, &apos;abc&apos;);</span><br><span class="line">thread-2： put(1, &apos;efg&apos;);</span><br></pre></td></tr></table></figure>
<p>假设此时Hash表的长度为10，且已经有两个元素在，负载因子为默认值0.75f，那么操作过程一定不会扩容，并且两个线程put的key都是1，那么它们将会分配到同一个table中，下方代码为put方法中的其中一段，其主要作用是遍历当前表内Node，寻找与当前key一样的Node结点，之后再做添加/更新操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">       p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// A</span></span><br><span class="line">       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">           treeifyBin(tab, hash);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设两个线程同时执行到了<code>A</code>这个位置，此时获取到的<code>p</code>是统一个对象，下一刻，cpu运转，两个线程同时运行，那么<code>p.next</code>的值将会是最后一个线程put的value值，而前一个则会丢失，这就会导致丢数据的情况！</p>
<p>当然该情景同样会发生于<code>resize</code>和<code>remove</code>操作，至于为什么，大家可以思考一下！</p>
<h3 id="size不准确"><a class="header-anchor" href="#size不准确">¶</a>size不准确</h3>
<p>这个就很简单了，为什么不准确呢，来看一下size变量在HashMap内部的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient int size;</span><br></pre></td></tr></table></figure>
<p>内存不可见并且增减操作未加锁，多线程操作下属于非原子操作！</p>
<h3 id="闭环死锁"><a class="header-anchor" href="#闭环死锁">¶</a>闭环死锁</h3>
<p>这个问题在JDK1.8版本的HashMap中已经不存在了，至于为啥，我要先讲一下在1.8之前的HashMap为什么会存在闭环死锁问题！</p>
<p>从<code>闭环</code>这个名词上我们分析一下是什么问题，什么是闭环的，如果链表形成了一个环会不会就是闭环呢？而链表如何才会形成环？带着这些问题，我们在脑海中抽象出一个模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br><span class="line">B--&gt;A</span><br></pre></td></tr></table></figure>
<p>假设某一个Table中的Node链表发生了上述问题，那么我们在遍历时进行<code>do{ }while ((e = e.next) != null);</code>操作就会发生死锁的问题，那么看来我们的猜想方向是正确的，那么我们就具体分析一下HashMap在什么操作之中会产生闭环的问题，不过在此之前，我们要明白因果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因：???</span><br><span class="line">果：闭环</span><br></pre></td></tr></table></figure>
<p>我们知道，只有当两个结点内部的<code>next</code>相互引用对方的时候才会死锁，这种场景只能在两个已经存在同一个链上的结点同时以<code>相反的方向</code>被操作<code>next</code>引用的时候才会发生，而在HashMap内部，符合这种场景的只有一个方法：<code>resize</code>，那我们就来看一下JDK1.7的<code>resize</code>方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">    useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="comment">//fu</span></span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入<code>transfer</code>方法中，其内部实现了扩容过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="comment">// A</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，在JDK1.7的HashMap的扩容实现中，老的Table中的Node链的顺序赋值给新的Table中时的操作是反置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure>
<p>上述操作是将当前Node的next指针指向当前Table的头结点，之后当前Node又变为了Table的头结点，此时假设A、B两个线程同时执行到了<code>transfer</code>方法中的<code>A</code>位置，并且此时的<code>oldTable</code>和<code>newTable</code>的结构是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">oldTable[]</span><br><span class="line">table-1: a -&gt; b -&gt; c -&gt; null</span><br><span class="line">table-2: null</span><br><span class="line">table-3: null</span><br><span class="line"></span><br><span class="line">newTable[]</span><br><span class="line">table-1: null</span><br><span class="line">table-2: null</span><br><span class="line">table-3: null</span><br><span class="line">table-4: null</span><br><span class="line">table-5: null</span><br><span class="line">table-6: null</span><br></pre></td></tr></table></figure>
<p>如果很巧，两个线程在同一个CPU上执行，那么就会存在一个抢占时间片的场景，假设A先抢到了时间片，然后执行一番操作之后，<code>oldTable</code>和<code>newTable</code>的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">oldTable[]</span><br><span class="line">table-1: a -&gt; null</span><br><span class="line">table-2: null</span><br><span class="line">table-3: null</span><br><span class="line"></span><br><span class="line">newTable[]</span><br><span class="line">table-1: null</span><br><span class="line">table-2: c -&gt; b -&gt; a</span><br><span class="line">table-3: null</span><br><span class="line">table-4: null</span><br><span class="line">table-5: null</span><br><span class="line">table-6: null</span><br></pre></td></tr></table></figure>
<p>之后还没等它做<code>oldTable = newTable</code>操作，B抢到了时间片，并也做了同样一番操作，<code>oldTable</code>和<code>newTable</code>的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">oldTable[]</span><br><span class="line">table-1: a -&gt; null</span><br><span class="line">table-2: null</span><br><span class="line">table-3: null</span><br><span class="line"></span><br><span class="line">newTable[]</span><br><span class="line">table-1: null</span><br><span class="line">table-2: a -&gt; c -&gt; b -&gt; a</span><br><span class="line">table-3: null</span><br><span class="line">table-4: null</span><br><span class="line">table-5: null</span><br><span class="line">table-6: null</span><br></pre></td></tr></table></figure>
<p>此时A或者B谁先<code>oldTable = newTable</code>已经无所谓了，因为<code>newTable</code>中已经产生了闭环，之后在进行get或者put操作时，如果不小心触发到了while循环，那将会一直死循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//do some thing</span></span><br><span class="line">&#125;<span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  <span class="comment">//e = e.next将会永不为空</span></span><br></pre></td></tr></table></figure>
<p>从上述场景产生的过程中我们发现，<code>a -&gt; c -&gt; b -&gt; a</code>这种闭环问题的罪魁祸首是因为1.7中的HashMap在扩容时为了免去再次遍历链表，很聪明的将当前结点作为新链表的头结点，这就会导致顺序反转，所以无序化导致了闭环的产生，而这种问题不仅仅是在HashMap中体现，Mysql的死锁问题的原因常常也是因为反序加行锁导致的！</p>
<p>而在开头说过，JDK1.8已经避免了这个问题，这是为什么呢？看下代码就知道了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">   Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">   Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">   Node&lt;K,V&gt; next;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       next = e.next;</span><br><span class="line">       <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">               loHead = e;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               loTail.next = e;</span><br><span class="line">           loTail = e;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">               hiHead = e;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               hiTail.next = e;</span><br><span class="line">           hiTail = e;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">       loTail.next = <span class="keyword">null</span>;</span><br><span class="line">       newTab[j] = loHead;  <span class="comment">//A</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">       hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">       newTab[j + oldCap] = hiHead; <span class="comment">//B</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是扩容的操作，JDK1.8中的HashMap通过两个链分别去存储头结点和尾结点以保证它有序，并且不会频繁的去赋值<code>newTable</code>，而是在循环之后直接赋值（请注意A、B标记处），这样就非常简单的避免了产生闭环的陷阱！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/24/设计模式一：单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nico">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/24/设计模式一：单例模式/" itemprop="url">设计模式一：单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-24T09:33:00+08:00">
                2018-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是单例模式"><a class="header-anchor" href="#什么是单例模式">¶</a>什么是单例模式</h2>
<p>单例是最常用的设计模式之一，其表达的最主要的意思是一个对象在整个jvm堆内存中只有一个实例，这样可以保证无论从任何代码块获取的单例实例都是唯一的。</p>
<p><strong>单例的优缺点也很明显，优点有以下这些：</strong></p>
<ul>
<li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li>
<li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li>
<li>提供了对唯一实例的受控访问。</li>
<li>由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</li>
<li>允许可变数目的实例。</li>
<li>避免对共享资源的多重占用。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li>
<li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li>
</ul>
<p><strong>在很多场景单例模式是很有用的，例如配置容器，连接池等，在Java中获取编写一个单例也很简单（暂时屏蔽细节）：</strong></p>
<ul>
<li>第一步：私有化类构造</li>
<li>第二步：内部定义一个类型为类本身的静态私有变量</li>
<li>第三步：提供一个静态共有方法获取这个私有变量（获取之前赋值）</li>
</ul>
<p><strong>尤其是第三步，我们在获取这个私有变量的时候要对其进行赋值，那么就有两个阶段可以做这件事，</strong></p>
<ul>
<li>定义静态私有变量的时候直接赋值</li>
<li>调用公有静态方法的时候再赋值</li>
</ul>
<p>这就引出了两种实现模式：<code>饿汉模式</code>和<code>懒汉模式</code>。</p>
<h2 id="饿汉模式"><a class="header-anchor" href="#饿汉模式">¶</a>饿汉模式</h2>
<p>饿汉从字面上的意思我们可以想到一个特别饥饿的大汉，而对于单例来讲则是形容以<code>迫不及待</code>的方式去将私有实例赋值，代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Single &#123;</span><br><span class="line">	private static Single instance = new Single();</span><br><span class="line">	private Single() &#123;&#125;</span><br><span class="line">	public static Single getInstance() &#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式的好处是不会存在并发下安全隐患，但是坏处也可想而知，对于jvm加载的过程就会将<code>instance</code>变量赋值，也就意味着我们即使没有用到这个单例对象也会将其实例<code>new</code>出来，可想而知，我们的永久带将会为其分配内存，带来的后果是永久带内存变少。</p>
<h2 id="懒汉模式"><a class="header-anchor" href="#懒汉模式">¶</a>懒汉模式</h2>
<p>懒汉模式则是在调用公有静态方法时才会为私有变量赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Single &#123;</span><br><span class="line">	private volatile static Single instance = null;// 1</span><br><span class="line">	private Single() &#123;&#125;</span><br><span class="line">	public static Single getInstance() &#123;</span><br><span class="line">		if(instance == null) &#123; //2</span><br><span class="line">			synchronized (Single.class) &#123; //3</span><br><span class="line">				if(instance == null) &#123; //4</span><br><span class="line">					instance = new Single(); // 5</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之前的饿汉模式，我们有以下几个改动：</p>
<ul>
<li>标记1：增加volatile关键字保证<code>5</code>时不会指令重排</li>
<li>标记2：是为了提高程序的效率，当Single对象被创建以后，再获取Single对象时就不用去验证同步代码块的锁及后面的代码，直接返回Single对象</li>
<li>标记3：防止多线程下的重复执行</li>
<li>标记4：同<code>3</code>，当多个线程同时调用<code>getInstance</code>方法，此时<code>instance</code>为空，两个线程可以轻松越过<code>2</code>，来到<code>3</code>抢锁，一个线程率先抢占到并且为<code>instance</code>赋值后，如果没有<code>4</code>的<code>if</code>判断，第二个线程也会重复去为<code>instance</code>赋值，这就会导致创建多个实例。</li>
</ul>
<p>而我们使用<code>volatile</code>则是因为在标记<code>5</code>赋值的时候会发生指令重排的问题！</p>
<blockquote>
<p>在Java中看似顺序的代码在JVM中，可能会出现编译器或者CPU对这些操作指令进行了重新排序；在特定情况下，指令重排将会给我们的程序带来不确定的结果…</p>
</blockquote>
<p>对于<code>instance = new Single()</code>这一行代码，JVM执行的指令有多行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); //1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory); //2：初始化对象</span><br><span class="line">instance = memory; //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>
<p>经重排后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); //1：分配对象的内存空间</span><br><span class="line">instance = memory; //3：设置instance指向刚分配的内存地址，此时对象还没被初始化</span><br><span class="line">ctorInstance(memory); //2：初始化对象</span><br></pre></td></tr></table></figure>
<p>若有A线程进行完重排后的第二步，且未执行初始化对象。此时B线程来取instance时，发现instance不为空，于是便返回该值，但由于没有初始化完该对象，此时返回的对象是有问题的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/26395860?s=460&v=4" alt="Nico">
            
              <p class="site-author-name" itemprop="name">Nico</p>
              <p class="site-description motion-element" itemprop="description">我是Nico，梦想是做一名兴趣使然的码农，于是我一步步变强，后来我成为了光头</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ainilili" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://note.isnico.com/" title="Nico's笔记" target="_blank">Nico's笔记</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.abby.md/" title="Abby's博客" target="_blank">Abby's博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ilovey.live/" title="低调小熊猫" target="_blank">低调小熊猫</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhangsan.plus/" title="ZhangSan_Plus'博客" target="_blank">ZhangSan_Plus'博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小Nico</span>

  
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
